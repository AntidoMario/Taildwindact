"use strict";
Object.defineProperty(exports, "__esModule", {
    value: true
});
function _export(target, all) {
    for(var name in all)Object.defineProperty(target, name, {
        enumerable: true,
        get: all[name]
    });
}
_export(exports, {
    INTERNAL_FEATURES: function() {
        return INTERNAL_FEATURES;
    },
    isValidVariantFormatString: function() {
        return isValidVariantFormatString;
    },
    parseVariant: function() {
        return parseVariant;
    },
    getFileModifiedMap: function() {
        return getFileModifiedMap;
    },
    createContext: function() {
        return createContext;
    },
    getContext: function() {
        return getContext;
    }
});
const _fs = /*#__PURE__*/ _interop_require_default(require("fs"));
const _url = /*#__PURE__*/ _interop_require_default(require("url"));
const _postcss = /*#__PURE__*/ _interop_require_default(require("postcss"));
const _dlv = /*#__PURE__*/ _interop_require_default(require("dlv"));
const _postcssselectorparser = /*#__PURE__*/ _interop_require_default(require("postcss-selector-parser"));
const _transformThemeValue = /*#__PURE__*/ _interop_require_default(require("../util/transformThemeValue"));
const _parseObjectStyles = /*#__PURE__*/ _interop_require_default(require("../util/parseObjectStyles"));
const _prefixSelector = /*#__PURE__*/ _interop_require_default(require("../util/prefixSelector"));
const _isPlainObject = /*#__PURE__*/ _interop_require_default(require("../util/isPlainObject"));
const _escapeClassName = /*#__PURE__*/ _interop_require_default(require("../util/escapeClassName"));
const _nameClass = /*#__PURE__*/ _interop_require_wildcard(require("../util/nameClass"));
const _pluginUtils = require("../util/pluginUtils");
const _corePlugins = require("../corePlugins");
const _sharedState = /*#__PURE__*/ _interop_require_wildcard(require("./sharedState"));
const _toPath = require("../util/toPath");
const _log = /*#__PURE__*/ _interop_require_default(require("../util/log"));
const _negateValue = /*#__PURE__*/ _interop_require_default(require("../util/negateValue"));
const _isSyntacticallyValidPropertyValue = /*#__PURE__*/ _interop_require_default(require("../util/isSyntacticallyValidPropertyValue"));
const _generateRules = require("./generateRules");
const _cacheInvalidation = require("./cacheInvalidation.js");
const _offsets = require("./offsets.js");
const _featureFlags = require("../featureFlags.js");
const _formatVariantSelector = require("../util/formatVariantSelector");
function _interop_require_default(obj) {
    return obj && obj.__esModule ? obj : {
        default: obj
    };
}
function _getRequireWildcardCache(nodeInterop) {
    if (typeof WeakMap !== "function") return null;
    var cacheBabelInterop = new WeakMap();
    var cacheNodeInterop = new WeakMap();
    return (_getRequireWildcardCache = function(nodeInterop) {
        return nodeInterop ? cacheNodeInterop : cacheBabelInterop;
    })(nodeInterop);
}
function _interop_require_wildcard(obj, nodeInterop) {
    if (!nodeInterop && obj && obj.__esModule) {
        return obj;
    }
    if (obj === null || typeof obj !== "object" && typeof obj !== "function") {
        return {
            default: obj
        };
    }
    var cache = _getRequireWildcardCache(nodeInterop);
    if (cache && cache.has(obj)) {
        return cache.get(obj);
    }
    var newObj = {};
    var hasPropertyDescriptor = Object.defineProperty && Object.getOwnPropertyDescriptor;
    for(var key in obj){
        if (key !== "default" && Object.prototype.hasOwnProperty.call(obj, key)) {
            var desc = hasPropertyDescriptor ? Object.getOwnPropertyDescriptor(obj, key) : null;
            if (desc && (desc.get || desc.set)) {
                Object.defineProperty(newObj, key, desc);
            } else {
                newObj[key] = obj[key];
            }
        }
    }
    newObj.default = obj;
    if (cache) {
        cache.set(obj, newObj);
    }
    return newObj;
}
const INTERNAL_FEATURES = Symbol();
const VARIANT_TYPES = {
    AddVariant: Symbol.for("ADD_VARIANT"),
    MatchVariant: Symbol.for("MATCH_VARIANT")
};
const VARIANT_INFO = {
    Base: 1 << 0,
    Dynamic: 1 << 1
};
function prefix(context, selector) {
    let prefix = context.tailwindConfig.prefix;
    return typeof prefix === "function" ? prefix(selector) : prefix + selector;
}
function normalizeOptionTypes({ type ="any" , ...options }) {
    let types = [].concat(type);
    return {
        ...options,
        types: types.map((type)=>{
            if (Array.isArray(type)) {
                return {
                    type: type[0],
                    ...type[1]
                };
            }
            return {
                type,
                preferOnConflict: false
            };
        })
    };
}
function parseVariantFormatString(input) {
    /** @type {string[]} */ let parts = [];
    // When parsing whitespace around special characters are insignificant
    // However, _inside_ of a variant they could be
    // Because the selector could look like this
    // @media { &[data-name="foo bar"] }
    // This is why we do not skip whitespace
    let current = "";
    let depth = 0;
    for(let idx = 0; idx < input.length; idx++){
        let char = input[idx];
        if (char === "\\") {
            // Escaped characters are not special
            current += "\\" + input[++idx];
        } else if (char === "{") {
            // Nested rule: start
            ++depth;
            parts.push(current.trim());
            current = "";
        } else if (char === "}") {
            // Nested rule: end
            if (--depth < 0) {
                throw new Error(`Your { and } are unbalanced.`);
            }
            parts.push(current.trim());
            current = "";
        } else {
            // Normal character
            current += char;
        }
    }
    if (current.length > 0) {
        parts.push(current.trim());
    }
    parts = parts.filter((part)=>part !== "");
    return parts;
}
function insertInto(list, value, { before =[]  } = {}) {
    before = [].concat(before);
    if (before.length <= 0) {
        list.push(value);
        return;
    }
    let idx = list.length - 1;
    for (let other of before){
        let iidx = list.indexOf(other);
        if (iidx === -1) continue;
        idx = Math.min(idx, iidx);
    }
    list.splice(idx, 0, value);
}
function parseStyles(styles) {
    if (!Array.isArray(styles)) {
        return parseStyles([
            styles
        ]);
    }
    return styles.flatMap((style)=>{
        let isNode = !Array.isArray(style) && !(0, _isPlainObject.default)(style);
        return isNode ? style : (0, _parseObjectStyles.default)(style);
    });
}
function getClasses(selector, mutate) {
    let parser = (0, _postcssselectorparser.default)((selectors)=>{
        let allClasses = [];
        if (mutate) {
            mutate(selectors);
        }
        selectors.walkClasses((classNode)=>{
            allClasses.push(classNode.value);
        });
        return allClasses;
    });
    return parser.transformSync(selector);
}
/**
 * Ignore everything inside a :not(...). This allows you to write code like
 * `div:not(.foo)`. If `.foo` is never found in your code, then we used to
 * not generated it. But now we will ignore everything inside a `:not`, so
 * that it still gets generated.
 *
 * @param {selectorParser.Root} selectors
 */ function ignoreNot(selectors) {
    selectors.walkPseudos((pseudo)=>{
        if (pseudo.value === ":not") {
            pseudo.remove();
        }
    });
}
function extractCandidates(node, state = {
    containsNonOnDemandable: false
}, depth = 0) {
    let classes = [];
    let selectors = [];
    if (node.type === "rule") {
        // Handle normal rules
        selectors.push(...node.selectors);
    } else if (node.type === "atrule") {
        // Handle at-rules (which contains nested rules)
        node.walkRules((rule)=>selectors.push(...rule.selectors));
    }
    for (let selector of selectors){
        let classCandidates = getClasses(selector, ignoreNot);
        // At least one of the selectors contains non-"on-demandable" candidates.
        if (classCandidates.length === 0) {
            state.containsNonOnDemandable = true;
        }
        for (let classCandidate of classCandidates){
            classes.push(classCandidate);
        }
    }
    if (depth === 0) {
        return [
            state.containsNonOnDemandable || classes.length === 0,
            classes
        ];
    }
    return classes;
}
function withIdentifiers(styles) {
    return parseStyles(styles).flatMap((node)=>{
        let nodeMap = new Map();
        let [containsNonOnDemandableSelectors, candidates] = extractCandidates(node);
        // If this isn't "on-demandable", assign it a universal candidate to always include it.
        if (containsNonOnDemandableSelectors) {
            candidates.unshift(_sharedState.NOT_ON_DEMAND);
        }
        // However, it could be that it also contains "on-demandable" candidates.
        // E.g.: `span, .foo {}`, in that case it should still be possible to use
        // `@apply foo` for example.
        return candidates.map((c)=>{
            if (!nodeMap.has(node)) {
                nodeMap.set(node, node);
            }
            return [
                c,
                nodeMap.get(node)
            ];
        });
    });
}
function isValidVariantFormatString(format) {
    return format.startsWith("@") || format.includes("&");
}
function parseVariant(variant) {
    variant = variant.replace(/\n+/g, "").replace(/\s{1,}/g, " ").trim();
    let fns = parseVariantFormatString(variant).map((str)=>{
        if (!str.startsWith("@")) {
            return ({ format  })=>format(str);
        }
        let [, name, params] = /@(\S*)( .+|[({].*)?/g.exec(str);
        var _params_trim;
        return ({ wrap  })=>{
            return wrap(_postcss.default.atRule({
                name,
                params: (_params_trim = params === null || params === void 0 ? void 0 : params.trim()) !== null && _params_trim !== void 0 ? _params_trim : ""
            }));
        };
    }).reverse();
    return (api)=>{
        for (let fn of fns){
            fn(api);
        }
    };
}
/**
 *
 * @param {any} tailwindConfig
 * @param {any} context
 * @param {object} param2
 * @param {Offsets} param2.offsets
 */ function buildPluginApi(tailwindConfig, context, { variantList , variantMap , offsets , classList  }) {
    function getConfigValue(path, defaultValue) {
        return path ? (0, _dlv.default)(tailwindConfig, path, defaultValue) : tailwindConfig;
    }
    function applyConfiguredPrefix(selector) {
        return (0, _prefixSelector.default)(tailwindConfig.prefix, selector);
    }
    function prefixIdentifier(identifier, options) {
        if (identifier === _sharedState.NOT_ON_DEMAND) {
            return _sharedState.NOT_ON_DEMAND;
        }
        if (!options.respectPrefix) {
            return identifier;
        }
        return context.tailwindConfig.prefix + identifier;
    }
    function resolveThemeValue(path, defaultValue, opts = {}) {
        let parts = (0, _toPath.toPath)(path);
        let value = getConfigValue([
            "theme",
            ...parts
        ], defaultValue);
        return (0, _transformThemeValue.default)(parts[0])(value, opts);
    }
    let variantIdentifier = 0;
    let api = {
        postcss: _postcss.default,
        prefix: applyConfiguredPrefix,
        e: _escapeClassName.default,
        config: getConfigValue,
        theme: resolveThemeValue,
        corePlugins: (path)=>{
            if (Array.isArray(tailwindConfig.corePlugins)) {
                return tailwindConfig.corePlugins.includes(path);
            }
            return getConfigValue([
                "corePlugins",
                path
            ], true);
        },
        variants: ()=>{
            // Preserved for backwards compatibility but not used in v3.0+
            return [];
        },
        addBase (base) {
            for (let [identifier, rule] of withIdentifiers(base)){
                let prefixedIdentifier = prefixIdentifier(identifier, {});
                let offset = offsets.create("base");
                if (!context.candidateRuleMap.has(prefixedIdentifier)) {
                    context.candidateRuleMap.set(prefixedIdentifier, []);
                }
                context.candidateRuleMap.get(prefixedIdentifier).push([
                    {
                        sort: offset,
                        layer: "base"
                    },
                    rule
                ]);
            }
        },
        /**
     * @param {string} group
     * @param {Record<string, string | string[]>} declarations
     */ addDefaults (group, declarations) {
            const groups = {
                [`@defaults ${group}`]: declarations
            };
            for (let [identifier, rule] of withIdentifiers(groups)){
                let prefixedIdentifier = prefixIdentifier(identifier, {});
                if (!context.candidateRuleMap.has(prefixedIdentifier)) {
                    context.candidateRuleMap.set(prefixedIdentifier, []);
                }
                context.candidateRuleMap.get(prefixedIdentifier).push([
                    {
                        sort: offsets.create("defaults"),
                        layer: "defaults"
                    },
                    rule
                ]);
            }
        },
        addComponents (components, options) {
            let defaultOptions = {
                preserveSource: false,
                respectPrefix: true,
                respectImportant: false
            };
            options = Object.assign({}, defaultOptions, Array.isArray(options) ? {} : options);
            for (let [identifier, rule] of withIdentifiers(components)){
                let prefixedIdentifier = prefixIdentifier(identifier, options);
                classList.add(prefixedIdentifier);
                if (!context.candidateRuleMap.has(prefixedIdentifier)) {
                    context.candidateRuleMap.set(prefixedIdentifier, []);
                }
                context.candidateRuleMap.get(prefixedIdentifier).push([
                    {
                        sort: offsets.create("components"),
                        layer: "components",
                        options
                    },
                    rule
                ]);
            }
        },
        addUtilities (utilities, options) {
            let defaultOptions = {
                preserveSource: false,
                respectPrefix: true,
                respectImportant: true
            };
            options = Object.assign({}, defaultOptions, Array.isArray(options) ? {} : options);
            for (let [identifier, rule] of withIdentifiers(utilities)){
                let prefixedIdentifier = prefixIdentifier(identifier, options);
                classList.add(prefixedIdentifier);
                if (!context.candidateRuleMap.has(prefixedIdentifier)) {
                    context.candidateRuleMap.set(prefixedIdentifier, []);
                }
                context.candidateRuleMap.get(prefixedIdentifier).push([
                    {
                        sort: offsets.create("utilities"),
                        layer: "utilities",
                        options
                    },
                    rule
                ]);
            }
        },
        matchUtilities: function(utilities, options) {
            let defaultOptions = {
                respectPrefix: true,
                respectImportant: true,
                modifiers: false
            };
            options = normalizeOptionTypes({
                ...defaultOptions,
                ...options
            });
            let offset = offsets.create("utilities");
            for(let identifier in utilities){
                let prefixedIdentifier = prefixIdentifier(identifier, options);
                let rule = utilities[identifier];
                classList.add([
                    prefixedIdentifier,
                    options
                ]);
                function wrapped(modifier, { isOnlyPlugin  }) {
                    let [value, coercedType, utilityModifier] = (0, _pluginUtils.coerceValue)(options.types, modifier, options, tailwindConfig);
                    if (value === undefined) {
                        return [];
                    }
                    if (!options.types.some(({ type  })=>type === coercedType)) {
                        if (isOnlyPlugin) {
                            _log.default.warn([
                                `Unnecessary typehint \`${coercedType}\` in \`${identifier}-${modifier}\`.`,
                                `You can safely update it to \`${identifier}-${modifier.replace(coercedType + ":", "")}\`.`
                            ]);
                        } else {
                            return [];
                        }
                    }
                    if (!(0, _isSyntacticallyValidPropertyValue.default)(value)) {
                        return [];
                    }
                    let extras = {
                        get modifier () {
                            if (!options.modifiers) {
                                _log.default.warn(`modifier-used-without-options-for-${identifier}`, [
                                    "Your plugin must set `modifiers: true` in its options to support modifiers."
                                ]);
                            }
                            return utilityModifier;
                        }
                    };
                    let modifiersEnabled = (0, _featureFlags.flagEnabled)(tailwindConfig, "generalizedModifiers");
                    let ruleSets = [].concat(modifiersEnabled ? rule(value, extras) : rule(value)).filter(Boolean).map((declaration)=>({
                            [(0, _nameClass.default)(identifier, modifier)]: declaration
                        }));
                    return ruleSets;
                }
                let withOffsets = [
                    {
                        sort: offset,
                        layer: "utilities",
                        options
                    },
                    wrapped
                ];
                if (!context.candidateRuleMap.has(prefixedIdentifier)) {
                    context.candidateRuleMap.set(prefixedIdentifier, []);
                }
                context.candidateRuleMap.get(prefixedIdentifier).push(withOffsets);
            }
        },
        matchComponents: function(components, options) {
            let defaultOptions = {
                respectPrefix: true,
                respectImportant: false,
                modifiers: false
            };
            options = normalizeOptionTypes({
                ...defaultOptions,
                ...options
            });
            let offset = offsets.create("components");
            for(let identifier in components){
                let prefixedIdentifier = prefixIdentifier(identifier, options);
                let rule = components[identifier];
                classList.add([
                    prefixedIdentifier,
                    options
                ]);
                function wrapped(modifier, { isOnlyPlugin  }) {
                    let [value, coercedType, utilityModifier] = (0, _pluginUtils.coerceValue)(options.types, modifier, options, tailwindConfig);
                    if (value === undefined) {
                        return [];
                    }
                    if (!options.types.some(({ type  })=>type === coercedType)) {
                        if (isOnlyPlugin) {
                            _log.default.warn([
                                `Unnecessary typehint \`${coercedType}\` in \`${identifier}-${modifier}\`.`,
                                `You can safely update it to \`${identifier}-${modifier.replace(coercedType + ":", "")}\`.`
                            ]);
                        } else {
                            return [];
                        }
                    }
                    if (!(0, _isSyntacticallyValidPropertyValue.default)(value)) {
                        return [];
                    }
                    let extras = {
                        get modifier () {
                            if (!options.modifiers) {
                                _log.default.warn(`modifier-used-without-options-for-${identifier}`, [
                                    "Your plugin must set `modifiers: true` in its options to support modifiers."
                                ]);
                            }
                            return utilityModifier;
                        }
                    };
                    let modifiersEnabled = (0, _featureFlags.flagEnabled)(tailwindConfig, "generalizedModifiers");
                    let ruleSets = [].concat(modifiersEnabled ? rule(value, extras) : rule(value)).filter(Boolean).map((declaration)=>({
                            [(0, _nameClass.default)(identifier, modifier)]: declaration
                        }));
                    return ruleSets;
                }
                let withOffsets = [
                    {
                        sort: offset,
                        layer: "components",
                        options
                    },
                    wrapped
                ];
                if (!context.candidateRuleMap.has(prefixedIdentifier)) {
                    context.candidateRuleMap.set(prefixedIdentifier, []);
                }
                context.candidateRuleMap.get(prefixedIdentifier).push(withOffsets);
            }
        },
        addVariant (variantName, variantFunctions, options = {}) {
            variantFunctions = [].concat(variantFunctions).map((variantFunction)=>{
                if (typeof variantFunction !== "string") {
                    // Safelist public API functions
                    return (api = {})=>{
                        let { args , modifySelectors , container , separator , wrap , format  } = api;
                        let result = variantFunction(Object.assign({
                            modifySelectors,
                            container,
                            separator
                        }, options.type === VARIANT_TYPES.MatchVariant && {
                            args,
                            wrap,
                            format
                        }));
                        if (typeof result === "string" && !isValidVariantFormatString(result)) {
                            throw new Error(`Your custom variant \`${variantName}\` has an invalid format string. Make sure it's an at-rule or contains a \`&\` placeholder.`);
                        }
                        if (Array.isArray(result)) {
                            return result.filter((variant)=>typeof variant === "string").map((variant)=>parseVariant(variant));
                        }
                        // result may be undefined with legacy variants that use APIs like `modifySelectors`
                        // result may also be a postcss node if someone was returning the result from `modifySelectors`
                        return result && typeof result === "string" && parseVariant(result)(api);
                    };
                }
                if (!isValidVariantFormatString(variantFunction)) {
                    throw new Error(`Your custom variant \`${variantName}\` has an invalid format string. Make sure it's an at-rule or contains a \`&\` placeholder.`);
                }
                return parseVariant(variantFunction);
            });
            insertInto(variantList, variantName, options);
            variantMap.set(variantName, variantFunctions);
            context.variantOptions.set(variantName, options);
        },
        matchVariant (variant, variantFn, options) {
            var _options_id;
            // A unique identifier that "groups" these variants together.
            // This is for internal use only which is why it is not present in the types
            let id = (_options_id = options === null || options === void 0 ? void 0 : options.id) !== null && _options_id !== void 0 ? _options_id : ++variantIdentifier;
            let isSpecial = variant === "@";
            let modifiersEnabled = (0, _featureFlags.flagEnabled)(tailwindConfig, "generalizedModifiers");
            var _options_values;
            for (let [key, value] of Object.entries((_options_values = options === null || options === void 0 ? void 0 : options.values) !== null && _options_values !== void 0 ? _options_values : {})){
                if (key === "DEFAULT") continue;
                api.addVariant(isSpecial ? `${variant}${key}` : `${variant}-${key}`, ({ args , container  })=>{
                    return variantFn(value, modifiersEnabled ? {
                        modifier: args === null || args === void 0 ? void 0 : args.modifier,
                        container
                    } : {
                        container
                    });
                }, {
                    ...options,
                    value,
                    id,
                    type: VARIANT_TYPES.MatchVariant,
                    variantInfo: VARIANT_INFO.Base
                });
            }
            var _options_values1;
            let hasDefault = "DEFAULT" in ((_options_values1 = options === null || options === void 0 ? void 0 : options.values) !== null && _options_values1 !== void 0 ? _options_values1 : {});
            api.addVariant(variant, ({ args , container  })=>{
                if ((args === null || args === void 0 ? void 0 : args.value) === _sharedState.NONE && !hasDefault) {
                    return null;
                }
                var // (JetBrains) plugins.
                _args_value;
                return variantFn((args === null || args === void 0 ? void 0 : args.value) === _sharedState.NONE ? options.values.DEFAULT : (_args_value = args === null || args === void 0 ? void 0 : args.value) !== null && _args_value !== void 0 ? _args_value : typeof args === "string" ? args : "", modifiersEnabled ? {
                    modifier: args === null || args === void 0 ? void 0 : args.modifier,
                    container
                } : {
                    container
                });
            }, {
                ...options,
                id,
                type: VARIANT_TYPES.MatchVariant,
                variantInfo: VARIANT_INFO.Dynamic
            });
        }
    };
    return api;
}
let fileModifiedMapCache = new WeakMap();
function getFileModifiedMap(context) {
    if (!fileModifiedMapCache.has(context)) {
        fileModifiedMapCache.set(context, new Map());
    }
    return fileModifiedMapCache.get(context);
}
function trackModified(files, fileModifiedMap) {
    let changed = false;
    let mtimesToCommit = new Map();
    for (let file of files){
        var _fs_statSync;
        if (!file) continue;
        let parsed = _url.default.parse(file);
        let pathname = parsed.hash ? parsed.href.replace(parsed.hash, "") : parsed.href;
        pathname = parsed.search ? pathname.replace(parsed.search, "") : pathname;
        let newModified = (_fs_statSync = _fs.default.statSync(decodeURIComponent(pathname), {
            throwIfNoEntry: false
        })) === null || _fs_statSync === void 0 ? void 0 : _fs_statSync.mtimeMs;
        if (!newModified) {
            continue;
        }
        if (!fileModifiedMap.has(file) || newModified > fileModifiedMap.get(file)) {
            changed = true;
        }
        mtimesToCommit.set(file, newModified);
    }
    return [
        changed,
        mtimesToCommit
    ];
}
function extractVariantAtRules(node) {
    node.walkAtRules((atRule)=>{
        if ([
            "responsive",
            "variants"
        ].includes(atRule.name)) {
            extractVariantAtRules(atRule);
            atRule.before(atRule.nodes);
            atRule.remove();
        }
    });
}
function collectLayerPlugins(root) {
    let layerPlugins = [];
    root.each((node)=>{
        if (node.type === "atrule" && [
            "responsive",
            "variants"
        ].includes(node.name)) {
            node.name = "layer";
            node.params = "utilities";
        }
    });
    // Walk @layer rules and treat them like plugins
    root.walkAtRules("layer", (layerRule)=>{
        extractVariantAtRules(layerRule);
        if (layerRule.params === "base") {
            for (let node of layerRule.nodes){
                layerPlugins.push(function({ addBase  }) {
                    addBase(node, {
                        respectPrefix: false
                    });
                });
            }
            layerRule.remove();
        } else if (layerRule.params === "components") {
            for (let node of layerRule.nodes){
                layerPlugins.push(function({ addComponents  }) {
                    addComponents(node, {
                        respectPrefix: false,
                        preserveSource: true
                    });
                });
            }
            layerRule.remove();
        } else if (layerRule.params === "utilities") {
            for (let node of layerRule.nodes){
                layerPlugins.push(function({ addUtilities  }) {
                    addUtilities(node, {
                        respectPrefix: false,
                        preserveSource: true
                    });
                });
            }
            layerRule.remove();
        }
    });
    return layerPlugins;
}
function resolvePlugins(context, root) {
    let corePluginList = Object.entries({
        ..._corePlugins.variantPlugins,
        ..._corePlugins.corePlugins
    }).map(([name, plugin])=>{
        if (!context.tailwindConfig.corePlugins.includes(name)) {
            return null;
        }
        return plugin;
    }).filter(Boolean);
    let userPlugins = context.tailwindConfig.plugins.map((plugin)=>{
        if (plugin.__isOptionsFunction) {
            plugin = plugin();
        }
        return typeof plugin === "function" ? plugin : plugin.handler;
    });
    let layerPlugins = collectLayerPlugins(root);
    // TODO: This is a workaround for backwards compatibility, since custom variants
    // were historically sorted before screen/stackable variants.
    let beforeVariants = [
        _corePlugins.variantPlugins["childVariant"],
        _corePlugins.variantPlugins["pseudoElementVariants"],
        _corePlugins.variantPlugins["pseudoClassVariants"],
        _corePlugins.variantPlugins["hasVariants"],
        _corePlugins.variantPlugins["ariaVariants"],
        _corePlugins.variantPlugins["dataVariants"]
    ];
    let afterVariants = [
        _corePlugins.variantPlugins["supportsVariants"],
        _corePlugins.variantPlugins["reducedMotionVariants"],
        _corePlugins.variantPlugins["prefersContrastVariants"],
        _corePlugins.variantPlugins["screenVariants"],
        _corePlugins.variantPlugins["orientationVariants"],
        _corePlugins.variantPlugins["directionVariants"],
        _corePlugins.variantPlugins["darkVariants"],
        _corePlugins.variantPlugins["forcedColorsVariants"],
        _corePlugins.variantPlugins["printVariant"]
    ];
    // This is a compatibility fix for the pre 3.4 dark mode behavior
    // `class` retains the old behavior, but `selector` keeps the new behavior
    let isLegacyDarkMode = context.tailwindConfig.darkMode === "class" || Array.isArray(context.tailwindConfig.darkMode) && context.tailwindConfig.darkMode[0] === "class";
    if (isLegacyDarkMode) {
        afterVariants = [
            _corePlugins.variantPlugins["supportsVariants"],
            _corePlugins.variantPlugins["reducedMotionVariants"],
            _corePlugins.variantPlugins["prefersContrastVariants"],
            _corePlugins.variantPlugins["darkVariants"],
            _corePlugins.variantPlugins["screenVariants"],
            _corePlugins.variantPlugins["orientationVariants"],
            _corePlugins.variantPlugins["directionVariants"],
            _corePlugins.variantPlugins["forcedColorsVariants"],
            _corePlugins.variantPlugins["printVariant"]
        ];
    }
    return [
        ...corePluginList,
        ...beforeVariants,
        ...userPlugins,
        ...afterVariants,
        ...layerPlugins
    ];
}
function registerPlugins(plugins, context) {
    let variantList = [];
    let variantMap = new Map();
    context.variantMap = variantMap;
    let offsets = new _offsets.Offsets();
    context.offsets = offsets;
    let classList = new Set();
    let pluginApi = buildPluginApi(context.tailwindConfig, context, {
        variantList,
        variantMap,
        offsets,
        classList
    });
    for (let plugin of plugins){
        if (Array.isArray(plugin)) {
            for (let pluginItem of plugin){
                pluginItem(pluginApi);
            }
        } else {
            plugin === null || plugin === void 0 ? void 0 : plugin(pluginApi);
        }
    }
    // Make sure to record bit masks for every variant
    offsets.recordVariants(variantList, (variant)=>variantMap.get(variant).length);
    // Build variantMap
    for (let [variantName, variantFunctions] of variantMap.entries()){
        context.variantMap.set(variantName, variantFunctions.map((variantFunction, idx)=>[
                offsets.forVariant(variantName, idx),
                variantFunction
            ]));
    }
    var _context_tailwindConfig_safelist;
    let safelist = ((_context_tailwindConfig_safelist = context.tailwindConfig.safelist) !== null && _context_tailwindConfig_safelist !== void 0 ? _context_tailwindConfig_safelist : []).filter(Boolean);
    if (safelist.length > 0) {
        let checks = [];
        for (let value of safelist){
            if (typeof value === "string") {
                context.changedContent.push({
                    content: value,
                    extension: "html"
                });
                continue;
            }
            if (value instanceof RegExp) {
                _log.default.warn("root-regex", [
                    "Regular expressions in `safelist` work differently in Tailwind CSS v3.0.",
                    "Update your `safelist` configuration to eliminate this warning.",
                    "https://tailwindcss.com/docs/content-configuration#safelisting-classes"
                ]);
                continue;
            }
            checks.push(value);
        }
        if (checks.length > 0) {
            let patternMatchingCount = new Map();
            let prefixLength = context.tailwindConfig.prefix.length;
            let checkImportantUtils = checks.some((check)=>check.pattern.source.includes("!"));
            for (let util of classList){
                let utils = Array.isArray(util) ? (()=>{
                    let [utilName, options] = util;
                    var _options_values;
                    let values = Object.keys((_options_values = options === null || options === void 0 ? void 0 : options.values) !== null && _options_values !== void 0 ? _options_values : {});
                    let classes = values.map((value)=>(0, _nameClass.formatClass)(utilName, value));
                    if (options === null || options === void 0 ? void 0 : options.supportsNegativeValues) {
                        // This is the normal negated version
                        // e.g. `-inset-1` or `-tw-inset-1`
                        classes = [
                            ...classes,
                            ...classes.map((cls)=>"-" + cls)
                        ];
                        // This is the negated version *after* the prefix
                        // e.g. `tw--inset-1`
                        // The prefix is already attached to util name
                        // So we add the negative after the prefix
                        classes = [
                            ...classes,
                            ...classes.map((cls)=>cls.slice(0, prefixLength) + "-" + cls.slice(prefixLength))
                        ];
                    }
                    if (options.types.some(({ type  })=>type === "color")) {
                        classes = [
                            ...classes,
                            ...classes.flatMap((cls)=>Object.keys(context.tailwindConfig.theme.opacity).map((opacity)=>`${cls}/${opacity}`))
                        ];
                    }
                    if (checkImportantUtils && (options === null || options === void 0 ? void 0 : options.respectImportant)) {
                        classes = [
                            ...classes,
                            ...classes.map((cls)=>"!" + cls)
                        ];
                    }
                    return classes;
                })() : [
                    util
                ];
                for (let util of utils){
                    for (let { pattern , variants =[]  } of checks){
                        // RegExp with the /g flag are stateful, so let's reset the last
                        // index pointer to reset the state.
                        pattern.lastIndex = 0;
                        if (!patternMatchingCount.has(pattern)) {
                            patternMatchingCount.set(pattern, 0);
                        }
                        if (!pattern.test(util)) continue;
                        patternMatchingCount.set(pattern, patternMatchingCount.get(pattern) + 1);
                        context.changedContent.push({
                            content: util,
                            extension: "html"
                        });
                        for (let variant of variants){
                            context.changedContent.push({
                                content: variant + context.tailwindConfig.separator + util,
                                extension: "html"
                            });
                        }
                    }
                }
            }
            for (let [regex, count] of patternMatchingCount.entries()){
                if (count !== 0) continue;
                _log.default.warn([
                    `The safelist pattern \`${regex}\` doesn't match any Tailwind CSS classes.`,
                    "Fix this pattern or remove it from your `safelist` configuration.",
                    "https://tailwindcss.com/docs/content-configuration#safelisting-classes"
                ]);
            }
        }
    }
    var _context_tailwindConfig_darkMode, _concat_;
    let darkClassName = (_concat_ = [].concat((_context_tailwindConfig_darkMode = context.tailwindConfig.darkMode) !== null && _context_tailwindConfig_darkMode !== void 0 ? _context_tailwindConfig_darkMode : "media")[1]) !== null && _concat_ !== void 0 ? _concat_ : "dark";
    // A list of utilities that are used by certain Tailwind CSS utilities but
    // that don't exist on their own. This will result in them "not existing" and
    // sorting could be weird since you still require them in order to make the
    // host utilities work properly. (Thanks Biology)
    let parasiteUtilities = [
        prefix(context, darkClassName),
        prefix(context, "group"),
        prefix(context, "peer")
    ];
    context.getClassOrder = function getClassOrder(classes) {
        // Sort classes so they're ordered in a deterministic manner
        let sorted = [
            ...classes
        ].sort((a, z)=>{
            if (a === z) return 0;
            if (a < z) return -1;
            return 1;
        });
        // Non-util classes won't be generated, so we default them to null
        let sortedClassNames = new Map(sorted.map((className)=>[
                className,
                null
            ]));
        // Sort all classes in order
        // Non-tailwind classes won't be generated and will be left as `null`
        let rules = (0, _generateRules.generateRules)(new Set(sorted), context, true);
        rules = context.offsets.sort(rules);
        let idx = BigInt(parasiteUtilities.length);
        for (const [, rule] of rules){
            let candidate = rule.raws.tailwind.candidate;
            var _sortedClassNames_get;
            // When multiple rules match a candidate
            // always take the position of the first one
            sortedClassNames.set(candidate, (_sortedClassNames_get = sortedClassNames.get(candidate)) !== null && _sortedClassNames_get !== void 0 ? _sortedClassNames_get : idx++);
        }
        return classes.map((className)=>{
            var _sortedClassNames_get;
            let order = (_sortedClassNames_get = sortedClassNames.get(className)) !== null && _sortedClassNames_get !== void 0 ? _sortedClassNames_get : null;
            let parasiteIndex = parasiteUtilities.indexOf(className);
            if (order === null && parasiteIndex !== -1) {
                // This will make sure that it is at the very beginning of the
                // `components` layer which technically means 'before any
                // components'.
                order = BigInt(parasiteIndex);
            }
            return [
                className,
                order
            ];
        });
    };
    // Generate a list of strings for autocompletion purposes, e.g.
    // ['uppercase', 'lowercase', ...]
    context.getClassList = function getClassList(options = {}) {
        let output = [];
        for (let util of classList){
            if (Array.isArray(util)) {
                var _utilOptions_types;
                let [utilName, utilOptions] = util;
                let negativeClasses = [];
                var _utilOptions_modifiers;
                let modifiers = Object.keys((_utilOptions_modifiers = utilOptions === null || utilOptions === void 0 ? void 0 : utilOptions.modifiers) !== null && _utilOptions_modifiers !== void 0 ? _utilOptions_modifiers : {});
                if (utilOptions === null || utilOptions === void 0 ? void 0 : (_utilOptions_types = utilOptions.types) === null || _utilOptions_types === void 0 ? void 0 : _utilOptions_types.some(({ type  })=>type === "color")) {
                    var _context_tailwindConfig_theme_opacity;
                    modifiers.push(...Object.keys((_context_tailwindConfig_theme_opacity = context.tailwindConfig.theme.opacity) !== null && _context_tailwindConfig_theme_opacity !== void 0 ? _context_tailwindConfig_theme_opacity : {}));
                }
                let metadata = {
                    modifiers
                };
                let includeMetadata = options.includeMetadata && modifiers.length > 0;
                var _utilOptions_values;
                for (let [key, value] of Object.entries((_utilOptions_values = utilOptions === null || utilOptions === void 0 ? void 0 : utilOptions.values) !== null && _utilOptions_values !== void 0 ? _utilOptions_values : {})){
                    // Ignore undefined and null values
                    if (value == null) {
                        continue;
                    }
                    let cls = (0, _nameClass.formatClass)(utilName, key);
                    output.push(includeMetadata ? [
                        cls,
                        metadata
                    ] : cls);
                    if ((utilOptions === null || utilOptions === void 0 ? void 0 : utilOptions.supportsNegativeValues) && (0, _negateValue.default)(value)) {
                        let cls = (0, _nameClass.formatClass)(utilName, `-${key}`);
                        negativeClasses.push(includeMetadata ? [
                            cls,
                            metadata
                        ] : cls);
                    }
                }
                output.push(...negativeClasses);
            } else {
                output.push(util);
            }
        }
        return output;
    };
    // Generate a list of available variants with meta information of the type of variant.
    context.getVariants = function getVariants() {
        // We use a unique, random ID for candidate names to avoid conflicts
        // We can't use characters like `_`, `:`, `@` or `.` because they might
        // be used as a separator
        let id = Math.random().toString(36).substring(7).toUpperCase();
        let result = [];
        for (let [name, options] of context.variantOptions.entries()){
            if (options.variantInfo === VARIANT_INFO.Base) continue;
            var _options_values;
            result.push({
                name,
                isArbitrary: options.type === Symbol.for("MATCH_VARIANT"),
                values: Object.keys((_options_values = options.values) !== null && _options_values !== void 0 ? _options_values : {}),
                hasDash: name !== "@",
                selectors ({ modifier , value  } = {}) {
                    let candidate = `TAILWINDPLACEHOLDER${id}`;
                    let rule = _postcss.default.rule({
                        selector: `.${candidate}`
                    });
                    let container = _postcss.default.root({
                        nodes: [
                            rule.clone()
                        ]
                    });
                    let before = container.toString();
                    var _context_variantMap_get;
                    let fns = ((_context_variantMap_get = context.variantMap.get(name)) !== null && _context_variantMap_get !== void 0 ? _context_variantMap_get : []).flatMap(([_, fn])=>fn);
                    let formatStrings = [];
                    for (let fn of fns){
                        var _options_values;
                        let localFormatStrings = [];
                        var _options_values_value;
                        let api = {
                            args: {
                                modifier,
                                value: (_options_values_value = (_options_values = options.values) === null || _options_values === void 0 ? void 0 : _options_values[value]) !== null && _options_values_value !== void 0 ? _options_values_value : value
                            },
                            separator: context.tailwindConfig.separator,
                            modifySelectors (modifierFunction) {
                                // Run the modifierFunction over each rule
                                container.each((rule)=>{
                                    if (rule.type !== "rule") {
                                        return;
                                    }
                                    rule.selectors = rule.selectors.map((selector)=>{
                                        return modifierFunction({
                                            get className () {
                                                return (0, _generateRules.getClassNameFromSelector)(selector);
                                            },
                                            selector
                                        });
                                    });
                                });
                                return container;
                            },
                            format (str) {
                                localFormatStrings.push(str);
                            },
                            wrap (wrapper) {
                                localFormatStrings.push(`@${wrapper.name} ${wrapper.params} { & }`);
                            },
                            container
                        };
                        let ruleWithVariant = fn(api);
                        if (localFormatStrings.length > 0) {
                            formatStrings.push(localFormatStrings);
                        }
                        if (Array.isArray(ruleWithVariant)) {
                            for (let variantFunction of ruleWithVariant){
                                localFormatStrings = [];
                                variantFunction(api);
                                formatStrings.push(localFormatStrings);
                            }
                        }
                    }
                    // Reverse engineer the result of the `container`
                    let manualFormatStrings = [];
                    let after = container.toString();
                    if (before !== after) {
                        // Figure out all selectors
                        container.walkRules((rule)=>{
                            let modified = rule.selector;
                            // Rebuild the base selector, this is what plugin authors would do
                            // as well. E.g.: `${variant}${separator}${className}`.
                            // However, plugin authors probably also prepend or append certain
                         Vñ⁄°h∑2l©=Û$6qö?∆ÊC;¬”+iÒ·D–%+∫SÓ∂≥E™(4¯∂∑lïB’d¬/ÂHŸVÛÀµIMâZ∞G$ûµ∏≈ãÙäÙgÖ∞QPì˜Åä≤†‡Îôd=Ù®›∂D41ﬂkQj˜ó40íó§Ô¡Ø?)Y3D√åt]â˚§)„◊¢áÁ	n≥"X%ÏãHJ?Ω=9ûê§ü1é,˝≥î`Wg–I…C^ïÏ{JN÷ñ>U¸J6ºvuÌWª÷lñ/ù>yb7≠%ã¢u	ãπ^–$ıÜ•X“¿Œ5ÿíÅ¯Jí;)kˆΩËk∫] ò6<∞O”Ù≠ïü|7¢M9êø]Ã¬w≠R&˘LÒu8ÿå‘T`yv9πúx3i≤Ì¯≠(Ëjõ$=–¥÷Cˆ&yê$,›JÛïát9˛i¸9B¬3x+ÖÓ@zç€_v°€%7O1CA…y¢……ç≥›ä ÅK∂Rÿå8T,ì¸·
…Ö2Pö4nÚ{„–é“∏¢—•Y©ÕØıº√g\w÷ÑCÉ∑ë∑5Û°Ÿ¸†Å]íÛ1	(–feBó…Ê”ØÆ|PÊE«JÍ;óˆÊdóC∂˘Pÿ$H©,:ˇ´,YÓøL∑ j9◊^kÔ|€RTwQV∏Ô÷wL
H'Rè_£¨´…k˚Æ3)~0{"J‡ÃŸ?Xóü¸èõë¢kı‰…7’ÜsÉæ‡aÿENÈTÛˆõ‘îÅo◊AU∂éD$ˇi]\_çØD√~v«êêﬁ}∑FÕõ…ÌÙ≈0‚=N€,ÇHÌ-›óOîÜ˜π$ ≥âh∫Eô
çh%u’CÏ›OÓa 'Ù‘àÃ∫FZi±`≠z⁄∫<ŸﬁØ±∞¸oÒ∏‡{¿+(-È	æ≤ªfﬁ†{aÄ‰wLŒ≥A©WÏïÜÔÏ¸ÀÁû+÷Ü¡∏_ıËÆl2ÛSz5J FÊ4Ö®QØÅi⁄≥ªà§ü“FMpoéÇYá1F∏q`^udá
=⁄gIq…büÀ±˜Õd{&∞‚ﬁ¡éπû¶ôs(xh•^t≠|Üå®€!Üfª†RFΩ∑ñ0‹(ÖÔOÌ∑}bçA“,<o„OM®Ê∆c~õïÄ∂=µÁ0à.ƒÁ–ïƒ≤˘…z¶ÂFcÅè-« }›6Z5Y/ÉwcAXVáõ⁄ÎÆ,o≥ÄsWLQ„Ÿ}”ÎRﬁcª˘fãM§ì{áwæ]˘◊ﬂõ¯P¡K‚Ò	ÔÍLº´±∏π>Êﬂ=>ÃMíàc*8?≠p÷$ú:/AqE/≈;«+dTô´†ÙA0_®˚w*úÌ√§»ÂãÛÖ$ßM&ƒJ¯dMóö.óïlk3fÂöÒÇ9ADŸ>⁄ù›ÿ≈†ÒV·…ﬂ€]¶ÿw≥$n÷¢.´ VÂñ€JÄ:‡æè(r(›ùÙY6dpw≠PÂ\òær'G;p	æµà¨˜ÎåìD€ıGkzëJÃí	S,•<ïãAöÉ∫à˙ªóAª¥I⁄…ﬂPkª#^ãıEmMÔñılûT±Á®≈6ë`MãkæÖdëgé”ôòò|c«	PA2
P$uT˚4®∆Ÿ‡Rõh2QùäA_çé4äUıÚ°ŒD0˝0⁄â¯$¢ëê*+T4´†(£´t≠L…“*FR|êÔ£~}éåVˇñÑƒ>bÎQª™ÈëLFWáéÕ”]›Í+¢E≤—b˘.U∂≈Ì≈h∏z`é<(˙Ä&ƒ√njŒÑﬁ\„äM]¯‡∂ª9GŒ´Ò¡¨îBèâ·øS=ñå‚©Ökd»∞øın`∫5¬´0(@KLı9ÛeGÜ*Ü:È_ûK0[ ˙`⁄_J¬[áÎ’ÜÀm‚AZuèìŒøRtΩ”,ù°IjUÕÊ\nøQ∫rWôfÃ˛£´âáºËÊúg±p‰K’◊ØCË‘®n….¯QÊæ4Vb±/É3ÇsŒÉ◊™õ«y	u{=wxˇ~z#	_R≤éH·◊ûÒÀıæn÷ç[WY*Aﬂy√F(”‰X,˚;ñwTÉæ®@ßñ<≤1√ë6∂õ†Q∞<7ÙTµ
X0Â÷FøMcY0ó∂éqøÉ_SÇÎ∆	∂Ûß+6äp$wﬂ»"Á¬ÉÑå¯l∆∞ı9_ÏßÂvŒrq‚”R$dr∞_á>a†∂ŒK-
ı1ΩËáﬁPqÎ,á
˘ú‚Uº ∫U»«‰˙¡î‹∆;CH3∫‹‹¯!%eñ“—Ì’ÒénAFLÿW˚†Ñ MU√*»Ù&¸®lns'Ö˝	ò◊„dÃ ‡ﬁHæÒ+«æ¶/≈M8é˝LÄÙR~¯#Ò(“qòI¢•ÔdßﬁΩ∞Œ2«†m¥˘œΩ∏[µ≥∂Ç„}»l«ùä3V"¨=ƒQn¸L∞’{ÙYÖøâ≤5„è\ùùQ˘'˛ú≥≥±tDÜ.mB¯⁄Íô®Q|˜∏ß‡»»j¢oƒ=QvAHˇ¥ä·~CGXπ¯†Ë7ëƒ’|;⁄+{¥íôÏmOÏÖº´Ÿ–·¨Ïª◊˜C¶V*Ng≈Ô◊@¢±æ|
û£sƒú£Ó∫áy<ªL4X®3(ù€‹ﬁI†HH0¿"ÒöjÌGc| nïÔ†aÈôﬁX1#◊˘⁄◊Ä∑Pt´c ∑Ox/ïf	|+∫“tQ	Å*	äd6”GÉì^œq©ú&m∂GtÇŸSr »˚o_‰¨n~1Öib≈5îËgë@‡mÍH› ä3>"üê&SióÀ=÷ë»nz á$måyR‘§=èÓ ≥vBÜaëT‹iØæxb{§—Ø˘≠ÑÆ˙UçÊF˙<Ï=£Ö)ﬁp¶áFƒ„DqØ⁄©œÚ_å\ d≥¸ΩZ?ÑÇÉày÷%AlÕu≠5Z—§îN7÷{ÖzGÏ∂˝ƒ|˜ª+E¯ñûú—‰…∏º=ëπY?HstÒ¢€wùabΩg÷'£j¥l·c˝Ú€'í∏•x($ôOø∂ÆJv{•Ù√ù	Áóv<¡ói%˝∆ùéxËÆ≈úlë¨∂æNÎŸVxÖS◊´ﬂ#p,µõ–„>XW¸Ω‘^Ämø"rê‚&a%ñ–Q’πe[Æ1Ú}∑¿ŒkË˝k“Rû–4_iî¡∫¶8öfâf9„Å=¨‚’Çk!e3ÇC)Î}3Xã/5™8Gw‡ œ,[∞ê í»ˇÑxÄ~è™f€Ì˜ËÓ{ˇ≤®õ&zj#."1∏Ø≥’g´oÀÇı[cÖ‰Ó>('ÿó∫+È¨BPÙ∫ÍREJÌœ:'^¢‰+wıü`˘ÃÒö
ÏI^À)—≥éH^˘ô∑Œ∑¯¥>ﬁ*-l;íà	çÏµÄﬁ&˛ Ë$7	„Y}HÂ@Â&ﬂ≈
∫ÌLùXâ&.1’H $“X@<â=ùO≠∞ü$–ﬂÑ˘‰ô¡ƒç.≤I¢%Z£]á1¿%#/ Y‡(ﬁ&%ípÒ–¢’ÄlÓI©¨œXsoM_fjûvßêÍtæFô]/∂ºî
k`ŒÆ$kX?òˇÿ
Äv…ä€#˙∏Â¨õé˜˜Z˘ØÕõ§s[ÿ
B7pî;?ÊD/£∏©Ç9Z\Z÷û:Ql}ïkÊWtv$ÑKÀ™^µû∫oˇ∂±ãs|3È%¨cz˝≈*m±m+ç#1µo]A‰$Ö˜ARr◊∫ˇ≈Á†Ú).K>ËmÀ¶—6s83≈Ê«Ñ9^Ÿ@˜Ai\©“Ì≥9 &€0ˇ^´#4·$ë8Uõ@≥_Mç6Çµ∂„<)£∆vIQ˜í∂ò”€°rˆß…®|´M±Ãƒ)]ZﬂÒBm˘Ø7»–µú6ÌÇˇ¯J‚ãj'^DIßõlÖ©C,Ï‰>èAt¨A¶É˙°…∆Ë√_ wÔ'œ0R‹:F|hˆ4Z‚£zÈA≈Òü“6AUHé3~[†x0≥q≥ÚÑ2¡ß/«HäWi°‰⁄£f‰:n‡≠ËXtÃ®ëÿ¯ÿ4)ìî)¯ƒÄÏ@zzÙ([A¢zÙ∏Fp^1áìrª÷©Úm≤Öõ:Ÿå¶é@35Î%Ì4x¯OA¢Lù‰}ú÷˜˚∏wªÄıEsâJùå”bÕuN◊1›“Ãwõ<ÍJÉáMy~:a£+Ër≥nÏﬁS†3[Ód@Ãã’Ã#¶3DG&‡ı8YÍ¶'≥ÿ%^∞Ë)`∞SÀ3ˇ©ÙsªäOÈ5Ëî±¸Èß“Ô∆uÎD¸bÙvÈÿÎÃ	<AHã:eÏàl” #†iÄùƒƒù‘9…Ío°ÿa‡¬z"’áy‚éû† ÿ+6önU˛I1:r80Ath‹o5:ƒà◊û:Dü˜aÏÎΩQÿ1∏üWÈõé?èüòÛÊ∂"Ÿ©<ïôFl‘ñ=§¿¢éI∑¡ß”xÒ∏‡EEr®qQå±ƒ,Çò;M™SÈ#]D⁄V¸ΩPê∑Ö&≈E^'≈éDI-3	–»XztL<LvQX⁄20‡:±öÉ1À(¶4îÕ7B€/π7á£r(j-®õà ∑)‰≤ß„A´•/\É‰u„Æ≥πnu©59;¢∞©‘±„|WlT—ÿXÕZÇÂ¨Î1∆‹7òw©∏i›Œl}ØÁ~´,†íDˇb€’≤’‹x÷&óÚbÈ3+√÷ÙM“m1ºŸ^ÿoõª•Á±RE≥ëô‚îåJSoâM'ÒêUtﬂ¯QãëÿÎøB]Â"g˜“≈† 0ç)Çﬁx{Î√å«È—ØÍ2®®ZmÜÊh*ãë ˚ãâñ$‡
ÔjMÇ"ìo`¬<»IGü±ÉÁh{—≤2— …•√¬ko©Á„Ç≈jIsú^qﬁl[p{àMÀ•9"?¥©£ÀZS8U€í„ì8˜˘N`	+ˆ¯‚]‘Ë»ÏëI´*§ı´ËCÊO„ÂnŸ\WIb≤z Ó3«Ø$Ñ≈Hô‹ÛË:&j2Tn‘?2…((Ã◊ﬁ‹-è˝[ƒëÂ·¬ü9¬$Ÿ¿tÑNI5H!	$˘íNF!6{ßﬂE¸aD>Q5ÛR~úw_Ü:‰˛ÿaÔ√EÇ¯πâõ™(∂9öãÍœ0¿[◊tÅ˚≠zn9Ë∞„æœ>z+§7%¢iáò≥Åö˜≈&Xß‡'∂ËáŒAÂEåjΩ41Ö|û•0{Ω‘E"dhÈÚ"∑˝§ÈˆÖKO8UèiˆeÀNHa«‘KcÖWÀƒüf≈rª∑}Úqﬂ™EÙHòZÊv–◊•÷Ñ{ËÀññıÛ∑Ä3|
+¶ãaû±Åâ≠üìù0;asˇÇkös´Î≠∂ØfZﬁıÃTX>æπ≈∆˝€Ú¯≠ñú≠<‹“§î®÷Ô∫Ôíäj∏@	"ZÄ•*bû`ÿé¬«xâg'0S
l)ˇ*Y22wÂ9¶Û©Û[òyv¿Y†458în?î”tØôœ˘´È(bÀ§ØÃ§B.ïÇ√Oã°»¨ú2=$^t©ï/£≤Ã∑ì¿§ÌO§˘3â+‡æËÿµòc≥ó8uÈ<·+„‡æ(L3k©x*‘˝]ÆÅHÅù2Õ7cçrî˝gW7=' B,Kz∏«$œ¥¨{…óì\Ä∆nŸNy]äSàé˙-™˘by{ﬂ¬diﬂn˚±Ü=°±-q)öV~—ˇòõV@ÖŸs5,jc?cı±V÷˘*¿Myƒ,Y◊‹É2Z//BNÙˆx,≤åæj‰dD
’ŸLòhÂâÛ ºì⁄≈–ö[≠‹Q»’¥˙®.T∞£»Là°œÕ∞5¿Ø£ía∂•Õ;∏ökÊÈAH®õÊiÚ‘!€r4£⁄œ‰hUr.p›‡úy_àN˝”‚÷ü#RfÄŒ"¸òòÿ5´ΩπËÌØCù$Í‚¥Yº+\úVÃ2ù]ç<≤ä˝âﬂ»!Ÿm¡“føt–h4äÕ∏ &∏ﬂ≠sèñÕD‘∫‰}£ªãÒÉπx|"‡ ·¬0gëµ›≈∑HTÀ∑ñW£Va2Äÿ!÷ÿÕ◊˙tØ€ ≤˝Ÿt†¥Ï¶“-Îœˆ¶±±˜«á1IõÂTﬁ”'eˆ-C5>´’.W†9[®>õ,=¿©5d.Ø∏Oee&éFR<‘y^Û¶Øµ<∏aéP®pcaK‡[Òº/c)T™ß
ô.≈"í∆jn›ÊÂÓãüi>±≥(o”Ê*ïDêÊ‚UÉ
Â≈Ù)ª∑tzK≤âAÑ¬WÅ‰e3ÕÉ∫ÉGÑ≤¯ù ¸Q´Í ^¸#◊üÕ˚≈øÑ™]-7∑¢:Fﬁ`&…€2Ú∆Ø‘à”hf˚⁄ã4Ëµ‰UX£kÀ~√J‡‡)¬Ÿ¥ﬂ≥éW6=4ÆëxæQÕ ßIôâPáNÑø'ÃÜûwbàa8|kµHÈ*±#à\)ù≤CG2œë Ó€í^ÒÜòH (cÇîºeëo®Úˇ¢‹ÿ˚”E®ÇÖΩâ:[ØX„‘÷ÃJ=‡2#g-fOÁoº‹	Ÿ
qæF`l?.a ;Œ›»s£ûJíÏŒQïúC`W\##ÎÜÈ«*¿<«ÊñS5ö=í˚´oﬁ≈>‚%VπÃ5èñGå,*õŒA [J‡s/	]¿JChÅt˚h[Ôó*ñ÷nóÑî¡ÿ∏ÇA÷’ZU7AT›”`Qi‰∆•®·‘PP’Zﬁ¨p
?ÂZ6<O2©XÕï LcD7
)X≥‚‚úΩl&íß Z“ñ‘∑jt˘5ÇØ?1}√˜k¸âtYﬁÏØ4põyp˙˙ÈÌN	˚$5OYsuıÆö¨wÅ!µıNœ
åéKºG∑Yh+ƒÔÊ„%Y”…NP^Ω¥∆ß,Wµ€'pô'å€7∞òÊp»∂8∫_¬ﬂu¢ú¬Ω∫9S¢ºe…É!£Ω≠ ››G´éXãæqRsûq∞ü®íóÅ˛Ql_»3§	«¶mÒL3	¢d·CÃzÑNY…XΩ¬÷$A=ÄÍÈ2v9u£>èæW">=ŸE[≥	™ˇ5LÙ$M§+Œ∞◊`ê[«ÔX—!lp‚Ë´f•/Û0Ì„>ë	YÒ¨q™UËÃgzàd'¯F–√TY/ﬂO)o:$ë‚Xhe;ÍwMï/aCﬁ¸ptRd?a/–6≤œ ¢dMpë±πÛ*¥xhö9ÈÊGå/çâ‹÷ΩL;qD\z¿‰_ë!ÍîRvúí>◊πÿ+‘Ó`÷Ç+c±r˚V£óâ·¬è~®IÎΩ3T3œßÈË5TGU&jWbß·ˇéo3¶Â1∑QnfïµÏ>·|P∏cÇO∆∑á∏€EÑ8rêv\íÇ`èﬂ·î⁄me!8òväBû£
¯—W2û(‹W%Ωï:åoô„êXø√h @ﬂÃ·l/†“+á@.zïÚëÃ`G“Û
£cO¬Ê±·°·¥nÒ&{ÊoÌ#}ﬂ—w™t¯ªÇT≈ﬁ‰l∑'Ím„$[ÙŸu„AﬂÜ\«ûT∂ìE¸*Óœrª‰:Ωó‘h=‹‹1≥¿•Ö§0ì’cœé≤°=Ñs;Ê∫M∫q~ÿ6Ft√ñp°ÿ{jË7›Â“Irc"”lÃS‹tÃ$I˙ù ©≤ ≥q›úÄ±Q\.« Ò¥BÂüSô˜0mÒÏrj„SÛ*=®úë√Ÿ’ß[°+Î*ÿ ˜ä´ÙÀÉb:q∞YB≈√=‰ÅñÊÈãÓ´≠ÍûG·˛W°#∏ŒÄyÇHd)HÄÔwÔ∫©Ä^jöq£º ¨]+ub@Ù∆©†5ﬂÆ!ﬁô≈ú“Å~,Ó¿€DÎM"fΩa≥#ªØ3Oà#†ÛX1.ä\ÖMZuC≈àun≈¡Kuv!ê∑Ó_‘áDnô±y©l‰=1	*¢§ÖËº÷¿5¥(ÔÁD≥
ïRÁ∏ê“W#i*ÁOÌ∏Ì±-_àﬂØ≈<µ&-i·UC^aUú¶üù£s‡îø'b«»á∆8¬d´÷JXU≤$e$úfVHÆ±◊	FR∑y;Báèô]OAD‡yjH¡™˜¡1»rƒ-≥∂◊~ejq˘cóÊ÷!—  ¶L{î^Ç1¿ÈFñôÁ∑˙8∑#4õ
ZatÄEg92˙4‹p¬‹[åT›†^úW/∂¿Äˇ<À0Yx}2‚P~ßäyv5^2w¬+∂c)':ºî}üÑÅÎé¯¢T∞sµñ;ß [OFÍ]C≥AkNö˘‰Æ;<¸dä'‘$Q∞i•ôªˆJ˝À{∫‹XàA*≥ëÈ¢®©Î›"£z˝Ì€(”Ä‚¬CFïK@‘ ,ç'4å+38µvÄ}ÓK ¶;‘ƒ‹ÁŸúçSJ?~¿ˇÉ4º≈'‡9Œp…œ˛>±ä¥Å(77åø‡5'RvÅèîå§uv7«)Âüï≈õ¥Ê]Œ Û\kãTô'ê¸Pf“û–É≤!≤Bƒíï°ò™≥MËù_;mfù˛∂À›„¸%uä+M
)dÓ*J˙„’˙’Ó±[©P$—ØúÁ?5•·^|˘¡’hŒ»"ú¡Ÿ∫,®ﬂ¡UBWﬂ≤-"⁄¿ªòo!)àCR?I>^ûïE:⁄ynŸ´ËI'√≤`k5\\:°Vô”@¨ôÁˇD◊°q»åíÇ!h"Ú´DÿIiÌ√8Ò∂á“bèã”ÃNÖ£≥“0˜˛Ÿ∏X¡›É7+uË≠©yeH?	Ω€ ≈œ6øZ«˜Æ ÷|/NÿyWÀÒ=ïb‡$_—!\LR˘uZßÊ&	68˙3õ´mtm:0c‰>©xk§>÷∂!ÕÉìHkUõ$yN˘
2«‰I≥~øEehQŸ˘ æ
÷\≥ò8˛ﬁ÷≈<ÂY∂¸FÛ≥´p¸SFàyg J·4“ÊLBQÌÚÃâ+⁄2:0~$^é'¸l>Jyìº–ëÕ4ÂÈ<≥hpUì rÎ∞_#X!g>ïª⁄UÓ¨⁄¶?1—(C÷„À‡ídp5›Í“Èg∏‡ÚÍ`èÓÒ∫:O≈»’äz/¢Q-~p`‹Î9‘
Àæ∂pÜó–=K/‚ûæI≤m∫[EV–èùÂ)/¸D r≥…X6â¢\a°ÍB˝o™ú=ièylMÇ+ˇI=»í [[g≈·ÈSS¡X¿¸¶Ö=D›ùØ·˚ıã*Ô¸û±¢ˇWÚê∆ˆ∑fk;¿äÿ@Ày∫"îñ1$wßrfÅ7ôvàÍ[IÙ∂vs6∂ì
umÂº'v‡∞yuP>Ωœ: ÌáıKù@]TÿˇSägDó¸Bë ¯°Å_c±∑ù!´&LZIC¥≥D -‡5=.ëZ¢!’b7uˇ∆¥D–˙√Á;üˇ.®∞“Õµ9ü àUìÂö–Ûh[¨ÅõI\$=9(‘nh’—©É47ö˛§N»¢°≈wÚM~åì‘‡\π-ì∂’Sò0MΩüÂ¸…l›∞ô∏üŸœöê∫€⁄¸^d¸?Æ¸§æ]K‹√r!Á¥q“ÜX¢÷ñˆÎn÷ƒàÈô(ŸU$†øﬂ¢ƒŒ:ã©√+Yw[ùuût¨)k˚:vÑΩjb1NãDÂXgLø{ì’WoÃÊä”6ömòGçG©¢Ã∫≈èCá÷yó2Ê—EIbyìzdÈ˚r©(í≤Ü¬ò“ñŸ:D`ÕMEÀê=uë[É¿˛5À∆Ÿ™%ﬁ´ <íÛƒ®U9O‹“óãÒ7 7≤≠Ú|Ëxc√±π¯6¡0æ¸Œ)”Éß
l Iz‹ç;`î√”áPèW~©e.ì±ëÇÍñÖêQònø)<‡P#}û†Æ¶‘Õ~≥§Æ1G7ÁiÛõÜ∏+ãL:âYn+A®V—Zπ=:™'x∆°îM~ΩMﬁ´ÿ√0°Õ^êÏ}A\Ä?‡Ni!ÁX£2‰Ìu≥ﬁtÔ~Òy^<Zï›ÁjëZ¡–‡4ë2¶ÕoAL+ÃnÎá>ìx ›ÏÚ•ÁL3 (DWÔú©Ïˆ8∞sIP~ AΩí@<⁄¯ºDbÖ∏
?™ò+e•Û‡–‰/õàÃè^1TËoOÏ{öb†¶∞^âoÍ`ûròa°ìiœ´zx≠˜·ñ…Ê¥èäAk¥:F*√Á≥˚âYÂuSZ«¸√ŒPUsE+:8fµm¨¨ëŸÉ¡ˆˆï|Ñâ7:wz*¸÷Md®yvÆ¸á¬Ò=yEÌ4P[ﬁÃ2mFsh.2î˚øûØ[Ñ÷¥2”≈ÑA¶<Mµ.ÓBuÁÄ$P"óèb+EÚ◊&ßè_‰aÿŒbWõ®†W°\jßkÿ›'LôTìµY7+b±æÌ2Ít(˜k˚\tó$‚ÜCD#≥„]€\,¥ùôcdèi∂πS sÛIx$‰^'ü£¿&≈fA•_.◊[~˘˘á}µ$PQ˙à@ınÑ√ªhËáì•y€vNI`◊n•üy≈‰@Ó1˙ÛI|>0„Ç±Aä-i!Í–’ûÇ÷Ω”gP¡`∞$ Ij¬bõÈ k»/ΩòQ¡nxu);˛’g˜Áo¥Â£∞ﬁ[Ë¿ÿ>MzåT–YaGx$æK∂LYL(÷UfŒ∫–}?˛PÈ83ı∏Ël˜Ó©™Y0jdQDÀêØd¡‹	˝„ö˝rƒqA4ﬁ7ñîNˇç”ﬂùí¡fa`'ºqõ–cIï#jQ$Hu#; uX†ÏrQ£dÓå2}∑œßıΩ-ÊVkGX1d8*h˘›Ègÿ(ôläwêgM‰0≠7ñçŒQÑ‚ôgâ°$Æ+:<⁄m°°'<Vı∏òSãL[Ö.åI∏lKJÒÂTj¢ÆÏ2‰≤≠Pn¡∆ ©J+ H€ˇÖ1óÓ ÄÊ]
ã™ıP*fq≈:Op*eåzˆbM÷q ƒCqèP–∫È˘‰uvòñ˜nû‘ M=õâGºé≤ŒÆQ+lÖ[(â;Ô≠ôx? «Y√*]cóe6◊¶Á(rmsáêf†;(=≤˝∆ë£Á(+•¥o⁄w◊‚ïZJ9⁄ßQÅl-fçïì‘ÊÄcWBÃ‘êÏÁ∆8d© Qr [·⁄ÔO˛ql¸˛Œ¸Üœ yz:mkcà∆ÏÉªÎ˛Yk êÑñN:¬yÓåÛá—Èk·÷ıÏap˜Í¿!ê4˝#√%9Âæq øΩiA!*‚(Û~dÀ0@¿⁄˘9C‚¸4¡<RŒD«R£”`øõ‚A˘)≠í∑|≈Ï-’*(ÂÄﬂ1∫¿íötÚù˜)/·òÖ≥6˘≠°R.2KÊ1±¢NxıÀ…Œ”s´Xâ®PxtµöEû~ÏW$õ∑PáVÂ±ë2ä°NlQNtï/S±rèÊŸwRÑOÂF*–Iuògˇ\b4_÷™I	‹>å“Œ„ ¨t%∞˙Lå≈Ø4ÅóÕ$'÷‡Ñ,3K˜Ω,5„m˘èµ≠B"mÂ3È?¸ÉQ≈F};¢xGsΩÉH]U9-È+Pn√Ú6ê‘∂Òxç¸v}”wÔ:3∆˛'◊ÄQ,+ŸnWƒû4¢ÅC€(ø∆…r´!âYnù £ñ˘˘(N∏–´ö’ÜÉÖjäÈÜ∫Tæ®Õ˝+>5fÓ5◊π∞*b0s!Ö˙]AØs≥|÷÷[òæEz‰Wô÷Úbê¬w/<ka∞Ü„yRÑÍ‚™k≤ÆVJY’lπ–´¶ˆFŒÒ™!/:Œ1˙IGk3≠=øØ˝Ñ∑∆¸‡¿:G∂ó?Ã|xÒ$0]mnxj⁄√ù»¯)kRÑ)Q¥∞V«/çàrWñˇlaA1¶´=5
 ‰¶Æì4