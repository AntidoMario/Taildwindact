/**
 * @module LRUCache
 */
declare const TYPE: unique symbol;
export type PosInt = number & {
    [TYPE]: 'Positive Integer';
};
export type Index = number & {
    [TYPE]: 'LRUCache Index';
};
export type UintArray = Uint8Array | Uint16Array | Uint32Array;
export type NumberArray = UintArray | number[];
declare class ZeroArray extends Array<number> {
    constructor(size: number);
}
export type { ZeroArray };
export type { Stack };
export type StackLike = Stack | Index[];
declare class Stack {
    #private;
    heap: NumberArray;
    length: number;
    static create(max: number): StackLike;
    constructor(max: number, HeapCls: {
        new (n: number): NumberArray;
    });
    push(n: Index): void;
    pop(): Index;
}
/**
 * Promise representing an in-progress {@link LRUCache#fetch} call
 */
export type BackgroundFetch<V> = Promise<V | undefined> & {
    __returned: BackgroundFetch<V> | undefined;
    __abortController: AbortController;
    __staleWhileFetching: V | undefined;
};
export type DisposeTask<K, V> = [
    value: V,
    key: K,
    reason: LRUCache.DisposeReason
];
export declare namespace LRUCache {
    /**
     * An integer greater than 0, reflecting the calculated size of items
     */
    type Size = number;
    /**
     * Integer greater than 0, representing some number of milliseconds, or the
     * time at which a TTL started counting from.
     */
    type Milliseconds = number;
    /**
     * An integer greater than 0, reflecting a number of items
     */
    type Count = number;
    /**
     * The reason why an item was removed from the cache, passed
     * to the {@link Disposer} methods.
     */
    type DisposeReason = 'evict' | 'set' | 'delete';
    /**
     * A method called upon item removal, passed as the
     * {@link OptionsBase.dispose} and/or
     * {@link OptionsBase.disposeAfter} options.
     */
    type Disposer<K, V> = (value: V, key: K, reason: DisposeReason) => void;
    /**
     * A function that returns the effective calculated size
     * of an entry in the cache.
     */
    type SizeCalculator<K, V> = (value: V, key: K) => Size;
    /**
     * Options provided to the
     * {@link OptionsBase.fetchMethod} function.
     */
    interface FetcherOptions<K, V, FC = unknown> {
        signal: AbortSignal;
        options: FetcherFetchOptions<K, V, FC>;
        /**
         * Object provided in the {@link FetchOptions.context} option to
         * {@link LRUCache#fetch}
         */
        context: FC;
    }
    /**
     * Status object that may be passed to {@link LRUCache#fetch},
     * {@link LRUCache#get}, {@link LRUCache#set}, and {@link LRUCache#has}.
     */
    interface Status<V> {
        /**
         * The status of a set() operation.
         *
         * - add: the item was not found in the cache, and was added
         * - update: the item was in the cache, with the same value provided
         * - replace: the item was in the cache, and replaced
         * - miss: the item was not added to the cache for some reason
         */
        set?: 'add' | 'update' | 'replace' | 'miss';
        /**
         * the ttl stored for the item, or undefined if ttls are not used.
         */
        ttl?: Milliseconds;
        /**
         * the start time for the item, or undefined if ttls are not used.
         */
        start?: Milliseconds;
        /**
         * The timestamp used for TTL calculation
         */
        now?: Milliseconds;
        /**
         * the remaining ttl for the item, or undefined if ttls are not used.
         */
        remainingTTL?: Milliseconds;
        /**
         * The calculated size for the item, if sizes are used.
         */
        entrySize?: Size;
        /**
         * The total calculated size of the cache, if sizes are used.
         */
        totalCalculatedSize?: Size;
        /**
         * A flag indicating that the item was not stored, due to exceeding the
         * {@link OptionsBase.maxEntrySize}
         */
        maxEntrySizeExceeded?: true;
        /**
         * The old value, specified in the case of `set:'update'` or
         * `set:'replace'`
         */
        oldValue?: V;
        /**
         * The results of a {@link LRUCache#has} operation
         *
         * - hit: the item was found in the cache
         * - stale: the item was found in the cache, but is stale
         * - miss: the item was not found in the cache
         */
        has?: 'hit' | 'stale' | 'miss';
        /**
         * The status of a {@link LRUCache#fetch} operation.
         * Note that this can change as the underlying fetch() moves through
         * various states.
         *
         * - inflight: there is another fetch() for this key which is in process
         * - get: there is no fetchMethod, so {@link LRUCache#get} was called.
         * - miss: the item is not in cache, and will be fetched.
         * - hit: the item is in the cache, and was resolved immediately.
         * - stale: the item is in the cache, but stale.
         * - refresh: the item is in the cache, and not stale, but
         *   {@link FetchOptions.forceRefresh} was specified.
         */
        fetch?: 'get' | 'inflight' | 'miss' | 'hit' | 'stale' | 'refresh';
        /**
         * The {@link OptionsBase.fetchMethod} was called
         */
        fetchDispatched?: true;
        /**
         * The cached value was updated after a successful call to
         * {@link OptionsBase.fetchMethod}
         */
        fetchUpdated?: true;
        /**
         * The reason for a fetch() rejection.  Either the error raised by the
         * {@link OptionsBase.fetchMethod}, or the reason for an
         * AbortSignal.
         */
        fetchError?: Error;
        /**
         * The fetch received an abort signal
         */
        fetchAborted?: true;
        /**
         * The abort signal received was ignored, and the fetch was allowed to
         * continue.
         */
        fetchAbortIgnored?: true;
        /**
         * The fetchMethod promise resolved successfully
         */
        fetchResolved?: true;
        /**
         * The fetchMethod promise was rejected
         */
        fetchRejected?: true;
        /**
         * The status of a {@link LRUCache#get} operation.
         *
         * - fetching: The item is currently being fetched.  If a previous value
         *   is present and allowed, that will be returned.
         * - stale: The item is in the cache, and is stale.
         * - hit: the item is in the cache
         * - miss: the item is not in the cache
         */
        get?: 'stale' | 'hit' | 'miss';
        /**
         * A fetch or get operation returned a stale value.
         */
        returnedStale?: true;
    }
    /**
     * options which override the options set in the LRUCache constructor
     * when calling {@link LRUCache#fetch}.
     *
     * This is the union of {@link GetOptions} and {@link SetOptions}, plus
     * {@link OptionsBase.noDeleteOnFetchRejection},
     * {@link OptionsBase.allowStaleOnFetchRejection},
     * {@link FetchOptions.forceRefresh}, and
     * {@link FetcherOptions.context}
     *
     * Any of these may be modified in the {@link OptionsBase.fetchMethod}
     * function, but the {@link GetOptions} fields will of course have no
     * effect, as the {@link LRUCache#get} call already happened by the time
     * the fetchMethod is called.
     */
    interface FetcherFetchOptions<K, V, FC = unknown> extends Pick<OptionsBase<K, V, FC>, 'allowStale' | 'updateAgeOnGet' | 'noDeleteOnStaleGet' | 'sizeCalculation' | 'ttl' | 'noDisposeOnSet' | 'noUpdateTTL' | 'noDeleteOnFetchRejection' | 'allowStaleOnFetchRejection' | 'ignoreFetchAbort' | 'allowStaleOnFetchAbort'> {
        status?: Status<V>;
        size?: Size;
    }
    /**
     * Options that may be passed to the {@link LRUCache#fetch} method.
     */
    interface FetchOptions<K, V, FC> extends FetcherFetchOptions<K, V, FC> {
        /**
         * Set to true to force a re-load of the existing data, even if it
         * is not yet stale.
         */
        forceRefresh?: boolean;
        /**
         * Context provided to the {@link OptionsBase.fetchMethod} as
         * the {@link FetcherOptions.context} param.
         *
         * If the FC type is specified as unknown (the default),
         * undefined or void, then this is optional.  Otherwise, it will
         * be required.
         */
        context?: FC;
        signal?: AbortSignal;
        status?: Status<V>;
    }
    /**
     * Options provided to {@link LRUCache#fetch} when the FC type is something
     * other than `unknown`, `undefined`, or `void`
     */
    interface FetchOptionsWithContext<K, V, FC> extends FetchOptions<K, V, FC> {
        context: FC;
    }
    /**
     * Options provided to {@link LRUCache#fetch} when the FC type is
     * `undefined` or `void`
     */
    interface FetchOptionsNoContext<K, V> extends FetchOptions<K, V, undefined> {
        context?: undefined;
    }
    /**
     * Options that may be passed to the {@link LRUCache#has} method.
     */
    interface HasOptions<K, V, FC> extends Pick<OptionsBase<K, V, FC>, 'updateAgeOnHas'> {
        status?: Status<V>;
    }
    /**
     * Options that may be passed to the {@link LRUCache#get} method.
     */
    interface GetOptions<K, V, FC> extends Pick<OptionsBase<K, V, FC>, 'allowStale' | 'updateAgeOnGet' | 'noDeleteOnStaleGet'> {
        status?: Status<V>;
    }
    /**
     * Options that may be passed to the {@link LRUCache#peek} method.
     */
    interface PeekOptions<K, V, FC> extends Pick<OptionsBase<K, V, FC>, 'allowStale'> {
    }
    /**
     * Options that may be passed to the {@link LRUCache#set} method.
     */
    interface SetOptions<K, V, FC> extends Pick<OptionsBase<K, V, FC>, 'sizeCalculation' | 'ttl' | 'noDisposeOnSet' | 'noUpdateTTL'> {
        /**
         * If size tracking is enabled, then setting an explicit size
         * in the {@link LRUCache#set} call will prevent calling the
         * {@link OptionsBase.sizeCalculation} function.
         */
        size?: Size;
        /**
         * If TTL tracking is enabled, then setting an explicit start
         * time in the {@link LRUCache#set} call will override the
         * default time from `performance.now()` or `Date.now()`.
         *
         * Note that it must be a valid value for whichever time-tracking
         * method is in use.
         */
        start?: Milliseconds;
        status?: Status<V>;
    }
    /**
     * The type signature for the {@link OptionsBase.fetchMethod} option.
     */
    type Fetcher<K, V, FC = unknown> = (key: K, staleValue: V | undefined, options: FetcherOptions<K, V, FC>) => Promise<V | undefined | void> | V | undefined | void;
    /**
     * Options which may be passed to the {@link LRUCache} constructor.
     *
     * Most of these may be overridden in the various options that use
     * them.
     *
     * Despite all being technically optional, the constructor requires that
     * a cache is at minimum limited by one or more of {@link OptionsBase.max},
     * {@link OptionsBase.ttl}, or {@link OptionsBase.maxSize}.
     *
     * If {@link OptionsBase.ttl} is used alone, then it is strongly advised
     * (and in fact required by the type definitions here) that the cache
     * also set {@link OptionsBase.ttlAutopurge}, to prevent potentially
     * unbounded storage.
     */
    interface OptionsBase<K, V, FC> {
        /**
         * The maximum number of items to store in the cache before evicting
         * old entries. This is read-only on the {@link LRUCache} instance,
         * and may not be overridden.
         *
         * If set, then storage space will be pre-allocated at construction
         * time, and the cache will perform significantly faster.
         *
         * Note that significantly fewer items may be stored, if
         * {@link OptionsBase.maxSize} and/or {@link OptionsBase.ttl} are also
         * set.
         */
        max?: Count;
        /**
         * Max time in milliseconds for items to live in cache before they are
         * considered stale.  Note that stale items are NOT preemptively removed
         * by default, and MAY live in the cache long after they have expired.
         *
         * Also, as this cache is optimized for LRU/MRU operations, some of
         * the staleness/TTL checks will reduce performance, as they will incur
         * overhead by deleting items.
         *
         * Must be an integer number of ms. If set to 0, this indicates "no TTL"
         *
         * @default 0
         */
        ttl?: Milliseconds;
        /**
         * Minimum amount of time in ms in which to check for staleness.
         * Defaults to 1, which means that the current time is checked
         * at most once per millisecond.
         *
         * Set to 0 to check the current time every time staleness is tested.
         * (This reduces performance, and is theoretically unnecessary.)
         *
         * Setting this to a higher value will improve performance somewhat
         * while using ttl tracking, albeit at the expense of keeping stale
         * items around a bit longer than their TTLs would indicate.
         *
         * @default 1
         */
        ttlResolution?: Milliseconds;
        /**
         * Preemptively remove stale items from the cache.
         * Note that this may significantly degrade performance,
         * especially if the cache is storing a large number of items.
         * It is almost always best to just leave the stale items in
         * the cache, and let them fall out as new items are added.
         *
         * Note that this means that {@link OptionsBase.allowStale} is a bit
         * pointless, as stale items will be deleted almost as soon as they
         * expire.
         *
         * @default false
         */
        ttlAutopurge?: boolean;
        /**
         * Update the age of items on {@link LRUCache#get}, renewing their TTL
         *
         * Has no effect if {@link OptionsBase.ttl} is not set.
         *
         * @default false
         */
        updateAgeOnGet?: boolean;
        /**
         * Update the age of items on {@link LRUCache#has}, renewing their TTL
         *
         * Has no effect if {@link OptionsBase.ttl} is not set.
         *
         * @default false
         */
        updateAgeOnHas?: boolean;
        /**
         * Allow {@link LRUCache#get} and {@link LRUCache#fetch} calls to return
         * stale data, if available.
         */
        allowStale?: boolean;
        /**
         * Function that is called on items when they are dropped from the cache.
         * This can be handy if you want to close file descriptors or do other
         * cleanup tasks when items are no longer accessible. Called with `key,
         * value`.  It's called before actually removing the item from the
         * internal cache, so it is *NOT* safe to re-add them.
         *
         * Use {@link OptionsBase.disposeAfter} if you wish to dispose items after
         * they have been full removed, when it is safe to add them back to the
         * cache.
         */
        dispose?: Disposer<K, V>;
        /**
         * The same as {@link OptionsBase.dispose}, but called *after* the entry
         * is completely removed and the cache is once again in a clean state.
         * It is safe to add an item right back into the cache at this point.
         * However, note that it is *very* easy to inadvertently create infinite
         * recursion this way.
         */
        disposeAfter?: Disposer<K, V>;
        /**
         * Set to true to suppress calling the
         * {@link OptionsBase.dispose} function if the entry key is
         * still accessible within the cache.
         * This may be overridden by passing an options object to
         * {@link LRUCache#set}.
         */
        noDisposeOnSet?: boolean;
        /**
         * Boolean flag to tell the cache to not update the TTL when
         * setting a new value for an existing key (ie, when updating a value
         * rather than inserting a new value).  Note that the TTL value is
         * _always_ set (if provided) when adding a new entry into the cache.
         *
         * Has no effect if a {@link OptionsBase.ttl} is not set.
         */
        noUpdateTTL?: boolean;
        /**
         * If you wish to track item size, you must provide a maxSize
         * note that we still will only keep up to max *actual items*,
         * if max is set, so size tracking may cause fewer than max items
         * to be stored.  At the extreme, a single item of maxSize size
         * will cause everything else in the cache to be dropped when it
         * is added.  Use with caution!
         *
         * Note also that size tracking can negatively impact performance,
         * though for most cases, only minimally.
         */
        maxSize?: Size;
        /**
         * The maximum allowed size for any single item in the cache.
         *
         * If a larger item is passed to {@link LRUCache#set} or returned by a
         * {@link OptionsBase.fetchMethod}, then it will not be stored in the
         * cache.
         */
        maxEntrySize?: Size;
        /**
         * A function that returns a number indicating the item's size.
         *
         * If not provided, and {@link OptionsBase.maxSize} or
         * {@link OptionsBase.maxEntrySize} are set, then all
         * {@link LRUCache#set} calls **must** provide an explicit
         * {@link SetOptions.size} or sizeCalculation param.
         */
        sizeCalculation?: SizeCalculator<K, V>;
        /**
         * Method that provides the implementation for {@link LRUCache#fetch}
         */
        fetchMethod?: Fetcher<K, V, FC>;
        /**
         * Set to true to suppress the deletion of stale data when a
         * {@link OptionsBase.fetchMethod} returns a rejected promise.
         */
        noDeleteOnFetchRejection?: boolean;
        /**
         * Do not delete stale items when they are retrieved with
         * {@link LRUCache#get}.
         *
         * Note that the `get` return value will still be `undefined`
         * unless {@link OptionsBase.allowStale} is true.
         */
        noDeleteOnStaleGet?: boolean;
        /**
         * Set to true to allow returning stale data when a
         * {@link OptionsBase.fetchMethod} throws an error or returns a rejected
         * promise.
         *
         * This differs from using {@link OptionsBase.allowStale} in that stale
         * data will ONLY be returned in the case that the
         * {@link LRUCache#fetch} fails, not any other times.
         */
        allowStaleOnFetchRejection?: boolean;
        /**
         * Set to true to return a stale value from the cache when the
         * `AbortSignal` passed to the {@link OptionsBase.fetchMethod} dispatches an `'abort'`
         * event, whether user-triggered, or due to internal cache behavior.
         *
         * Unless {@link OptionsBase.ignoreFetchAbort} is also set, the underlying
         * {@link OptionsBase.fetchMethod} will still be considered canceled, and
         * any value it returns will be ignored and not cached.
         *
         * Caveat: since fetches are aborted when a new value is explicitly
         * set in the cache, this can lead to fetch returning a stale value,
         * since that was the fallback value _at the moment the `fetch()` was
         * initiated_, even though the new updated value is now present in
         * the cache.
         *
         * For example:
         *
         * ```ts
         * const cache = new LRUCache<string, any>({
         *   ttl: 100,
         *   fetchMethod: async (url, oldValue, { signal }) =>  {
         *     const res = await fetch(url, { signal })
         *     return await res.json()
         *   }
         * })
         * cache.set('https://example.com/', { some: 'data' })
         * // 100ms go by...
         * const result = cache.fetch('https://example.com/')
         * cache.set('https://example.com/', { other: 'thing' })
         * console.log(await result) // { some: 'data' }
         * console.log(cache.get('https://example.com/')) // { other: 'thing' }
         * ```
         */
        allowStaleOnFetchAbort?: boolean;
        /**
         * Set to true to ignore the `abort` event emitted by the `AbortSignal`
         * object passed to {@link OptionsBase.fetchMethod}, and still cache the
         * resulting resolution value, as long as it is not `undefined`.
         *
         * When used on its own, this means aborted {@link LRUCache#fetch} calls are not
         * immediately resolved or rejected when they are aborted, and instead
         * take the full time to await.
         *
         * When used with {@link OptionsBase.allowStaleOnFetchAbort}, aborted
         * {@link LRUCache#fetch} calls will resolve immediately to their stale
         * cached value or `undefined`, and will continue to process and eventually
         * update the cache when they resolve, as long as the resulting value is
         * not `undefined`, thus supporting a "return stale on timeout while
         * refreshing" mechanism by passing `AbortSignal.timeout(n)` as the signal.
         *
         * **Note**: regardless of this setting, an `abort` event _is still
         * emitted on the `AbortSignal` object_, so may result in invalid results
         * when passed to other underlying APIs that use AbortSignals.
         *
         * This may be overridden in the {@link OptionsBase.fetchMethod} or the
         * call to {@link LRUCache#fetch}.
         */
        ignoreFetchAbort?: boolean;
    }
    interface OptionsMaxLimit<K, V, FC> extends OptionsBase<K, V, FC> {
        max: Count;
    }
    interface OptionsTTLLimit<K, V, FC> extends OptionsBase<K, V, FC> {
        ttl: Milliseconds;
        ttlAutopurge: boolean;
    }
    interface OptionsSizeLimit<K, V, FC> extends OptionsBase<K, V, FC> {
        maxSize: Size;
    }
    /**
     * The valid safe options for the {@link LRUCache} constructor
     */
    type Options<K, V, FC> = OptionsMaxLimit<K, V, FC> | OptionsSizeLimit<K, V, FC> | OptionsTTLLimit<K, V, FC>;
    /**
     * Entry objects used by {@link LRUCache#load} and {@link LRUCache#dump},
     * and returned by {@link LRUCache#info}.
     */
    interface Entry<V> {
        value: V;
        ttl?: Milliseconds;
        size?: Size;
        start?: Milliseconds;
    }
}
/**
 * Default export, the thing you're using this module to get.
 *
 * All properties from the options object (with the exception of
 * {@link OptionsBase.max} and {@link OptionsBase.maxSize}) are added as
 * normal public members. (`max` and `maxBase` are read-only getters.)
 * Changing any of these will alter the defaults for subsequent method calls,
 * but is otherwise safe.
 */
export declare class LRUCache<K extends {}, V extends {}, FC = unknown> implements Map<K, V> {
    #private;
    /**
     * {@link LRUCache.OptionsBase.ttl}
     */
    ttl: LRUCache.Milliseconds;
    /**
     * {@link LRUCache.OptionsBase.ttlResolution}
     */
    ttlResolution: LRUCache.Milliseconds;
    /**
     * {@link LRUCache.OptionsBase.ttlAutopurge}
     */
    ttlAutopurge: boolean;
    /**
     * {@link LRUCache.OptionsBase.updateAgeOnGet}
     */
    updateAgeOnGet: boolean;
    /**
     * {@link LRUCache.OptionsBase.updateAgeOnHas}
     */
    updateAgeOnHas: boolean;
    /**
     * {@link LRUCache.OptionsBase.allowStale}
     */
    allowStale: boolean;
    /**
     * {@link LRUCache.OptionsBase.noDisposeOnSet}
     */
    noDisposeOnSet: boolean;
    /**
     * {@link LRUCache.OptionsBase.noUpdateTTL}
     */
    noUpdateTTL: boolean;
    /**
     * {@link LRUCache.OptionsBase.maxEntrySize}
     */
    maxEntrySize: LRUCache.Size;
    /**
     * {@link LRUCache.OptionsBase.sizeCalculation}
     */
    sizeCalculation?: LRUCache.SizeCalculator<K, V>;
    /**
     * {@link LRUCache.OptionsBase.noDeleteOnFetchRejection}
     */
    noDeleteOnFetchRejection: boolean;
    /**
     * {@link LRUCache.OptionsBase.noDeleteOnStaleGet}
     */
    noDeleteOnStaleGet: boolean;
    /**
     * {@link LRUCache.OptionsBase.allowStaleOnFetchAbort}
     */
    allowStaleOnFetchAbort: boolean;
    /**
     * {@link LRUCache.OptionsBase.allowStaleOnFetchRejection}
     */
    allowStaleOnFetchRejection: boolean;
    /**
     * {@link LRUCache.OptionsBase.ignoreFetchAbort}
     */
    ignoreFetø/®y40SûÊ¦Üé¸÷˜¢óúú”1Ù½hYO‰Ru\ŠÙØE½ãˆ´Biê€%Eåü¨§9º"~lIş±_r„7Â<§†z©Hv|mô´èEÙOÔ/ãù)M{UÍgH;?á-Pì%!Û†Ø¯&©lDMÙ²®ö[M¼ú‹(MÌó=0şé–Î˜ÜÔ¼AY¬­^Ï¬‡ôÂ!3€HàC˜.ñ‰œ³uŸµ<oÚÓ&×Ş"İœú!½B`xéÔÈFNŠ¯>&VÚd9úvX¤2Ë@ÚQ«|Ìê¦@oQõ;ªˆîÑa´eÆÄûOß&jB ‘ˆh‰™R™Y&
ÊU:|íıQ¶mXVµUeìš•wí½NÅã¯TâÃy„äì1]¸W-j¿jeì£•2ZD+mkUn¡^òòc“·Ò~âœlPäĞ‹,{î4Nµ„Æ¢Y:½R+uÌ¢ë•@Ç*?-~a–iO5!lX "˜İ$xâ%ãˆ>S…³ñ%k¹ğÖ>=œn„kOYØ6¶ÎùÔŒ/™ªŠ*Èçü«FŸ‡PˆµğH¥²º? ßO»*, ?T"©Å×ü$"–dT3íÒW8‚ÚZ_V½ì¶\OÍß‡ÓÂ“~S`l€8Î¤†Œjïö»e¥ê±%j*C9¡†>
!D•Ve¡/+ÀÑ÷lş¹`5|ˆæÃø`›–ò¨“áÇ½‰€‘Q8reüe]ß|5;
àúznñD<ïì}ÈeŞRy²ÓcÃ‘´je):”½Qğ D„kÌ¿3‡ƒßwaÍm»,µè¹óş-^…­"dŞ"ü4!É¶“‚@zô*aé¤9bæåc?]áÈsp¾íìÏwåİú›¢ºƒûÛƒõx/3W	´i6Èñ¹×ê–ÁÈŠÅËŞ4U
ï™iñÊ?öäjÀæeİç>šró”Q ~´Úçgó ÀDec€?œ6÷Í‚/}I’…Oÿ64Û*ğxûä´V oû´Št:…ò<ùò/Æ=õ]³1²ÙL]½ªOEèğõ›pŸ‚ÄÆ5X|N
×½Ã	9¯Ã&›íšËÄë>l
ìĞˆ‡MÆ(Òv'53b8û2§Të—yHZíL>H
1áÅ° ôpq	¸´<,nÉ‘¶A*Æ(=)—Ñ:½40¨—ŸæãšŠˆ	ÃÏIt@ïoÇùA6¿ß]jgâ6JJü®Fß^ÁBx22QæhøwG×4.ÿ–Õé»Å…zİYÂ”}b'î,QWÆK¾L6İ¥)‘933üÃw6Ä•d¥F7†åÖYNYÙ$Š£ÈÚ+Èœ:u×ÅÌ÷’9V÷Ø@Ÿ~Êyˆ=×dm” ÷JÆ™İX“ÒO¢xÁ¶½¨¾fÊZû=>W·ÄAø+C±Û;j„‹®N¦çù“óÂ4=:èŸát²kfŠ¢•V"Ä(„®LIé›VÔ’ÛŸXå?tøxù+Z]6}QCØëó.’]	_	`ö‹bRJÍâxÓ²ö¥,ÎÈw!×bˆ÷àef‹àcÈˆ²]²âöt	±ZzÚ¤'làDóŠİñ<ş*Râ²Ÿ§d5]°®ÖFkFk†JÚµOÏ´x.o‚§~êE|4“X³M	S%VÊæÚ•ªû’oÆp‚G'Üó´S0‘aæpe·t™XéÔ‡² ¤»İ°ŒKr&(Œ‡ŠMZÛ°x+k`mé«Ş'.a^ÔLĞ¦¼QbqP‚Jcl8Öî;ì	µÑüØ´®4Œ£-¢ş6»{år…6 S¿DáDrfYF‘Dv:òq¦qÒ®§4]1x}"íé¾BÆz(ò”£¤¿ñ®œo=ıÂ…*}o’]º×o×’uYxÑ;/í–ïG›½@ãŸªùçÒIuü@â È'mÇƒbÕÚªwWë1±{ T¶¦k–yUôFj•!«æ¢Â©ïøÄıaí÷KÕ|_Œ	—®‹»E±GîÅsìa8h	¼lE:\³’ä(oêç9ƒ=·!mÍ!AõÚMSñí¨ïœˆŠ©¯	az*õm;Ä¥Ls¶~#´µÁ}T´=¾î~vÓº<F#M ªeWK`å
f™±l	å‘DE€f0KB¢ÙáŠB›C|xó…E?Rp?Avb¤C ğå[ëŞœ¦Û®ˆùÛ¶Fhfj	è-TRç“mqŞËœóc¤n#•¼À¾‰)¯53mWÄÚm{ğ "’µ!7
›»OÉåú>˜é/|A¤bôB4õÍ9òë"‘njØ/bçú&p•ŞôCôr6†‚¸+ú,&Ã’JÜå)±’iDÒw™¥"jäº?0ÿKÓiâÓÄ¯ğì¹€Õ’†²¶	‹„/‘âm!ÂµPó‡¼Z3à‹ÙŠJI­»¼Ó&´µŸÈÖ}¨mbPó¯SıÔÂ÷ç2x9ıVº†Ápb&ëT©!C‚ÊRÂ³ù! ¼SÜxFÇKœi§<!šù]\÷_Fv}ìØã[ÆŸÄÿgfª9÷hÒ—€_Hˆ†®\3û„‰şIx‰="²ß>¿WfCh£2”Í½¢70®LğÉcµZIEsãK?‹lPHdé¾
5—ÀV'£Ñâ¾dŸÕÅ»ö¥}²Fô;img<“íéÉÒşC6ÜxRê[S7×ò}©´‰¨ÀÏ¾ÌOĞÇŒ!™Ü6˜SÖïkñß0UÿX-ìu~÷-©MKÿõ—4¯O)ö
±uÜıì’Û{Òb°ïÉÓ#áÛªTğ-Æ·Î…“DjéÅşW¨/?P‚çs.°í	ˆ	Ä2k%ĞVŸyRÌb(«$$ú"-¶©2Ä²×ê¡BâvÅ³ÂXønÃ÷İ££(Ñá~Ä•|”‰iÚßÒ´ÄËtï4¦é¯Š‰µ°ÍKæl"¹ë$ñî»cCf™šõš‡
ÿ¡6ˆuë#{û’mÂ¹
uûO×€‰­ó-AÓ`4"a"H.ickL_b6L9)Á! ø¾fğ¥äıºGq®…ß“FŞ§k—†²y¾C×R÷ˆ\Á¶áVò¹ôRÅÃ3ç%éˆDûLÓ¸˜°Ïà¬!uğS”*º‹«Ö¢*¬”÷‡3$!‘ÆªU7VmœåG¢[—sÊèd´¢ 
™¨MY'Ò“±»SÄ¼BƒTŞ+idˆ2©i²0;ÈŠÉìW+-¡Ây>3“Şn’^m*æ "L#\qºûWÅh ‚Š€M+­+ü5ğğVÛ¤'C¯iqHÍêjb6ÊÏèÃkT¡áÎæ„¢ˆnFøŸE8ññ ˆpq§v}‚5ïwÑÔx¢ıW9#G{vuğ½Ù6ÛÎÑûõ8gó)™&‡±1Ş(R!ÂxrÚ¾ñÂœßx6ÕÃHÕ~’F†;–¨Cµ³6/jŸ¹H7z§#Y&+ñRr:=ù°:ÿq-êiêßº…•omB¾}H‹jš‡ÄtÌ|ÇªTTMi•ú©á
-UÉÜe*ÿ,g‹BŠ{XèfEDe¾VÙâen]Å+ß‡L¼P×B¢Ğ­òúbk¢ø"“ÒĞ—ÊùºÊ&[`\g\âõÅÚUq‡ú‘!ÖÃñsSÄ3~z¹”rÚ¢³âGÌø_nÙ>â:Š*—I5%¯‡TØô¬Šü*ç¨ZÊËj{ßClÏÌ¶BƒÜ,Øö›E_Z#†¬EYßı-Ì,rÍçdÒ[¸`íŸ…ëmMF§û¼à`%/¢3O¼y£Ì™Mæ‰Q;ˆR«‰>„ás±GØ\>ÑÚv¤?5M0ğ¤…W’H¾]4‹¢Ò,ğ°d“mrZ–Vte¥rÔyEf<ÁO†ìÌHøK@Î™ßW©"IXØşjıH¶0ƒ†ŠÆõˆX—Œ|ŒD¤vƒg¡…Êl¿ğ¸Îv¿ƒ KTÑÌn¬Gávè‘ìK.“ëÏ-jJän·¢®%@Îƒô+Òd{’-ˆm;ŒD•Ç|iZÙÒÏiêÏÿL–Ö]Ñ‡é‹´Åt6»ä¾o²ÒÈ¤Œ¢o3Z+‚ÊŸ›Y¹h×ÑyYoíĞcˆ|Ò¿k&™ŒG³§²ïÎ~ªm‹¸DDÕ€¯¾‘ÿ; UŠ/%é†Z»f÷Ss(ª§igDÑP¯Éˆ(ÏAqªd»~şªÅ×äaµ«?™Å×äÈ’¸Bq+–‹ê®5ùÊ½©goË6RÅïÂÉz¹Ü°€dµjÓ0b5{ºWH‡nÿp–±Âı1åÍÓyı‡.ûîwUˆ8Œç&÷Ïc±ñEr%BA×;ßZµ@í_?(¸^ú-„¶3UA={-eâıŠA™‰ã	ÓßmïDã(ĞŞ]–G¾ş¤Šù)Ø„S4œHv¸kI1ÑbnƒbŒ”[çš.G£Jl7×¸éÙ–›	û”s¸èÈr”Fæ[9++n;‰(Ç+·*Qæá:fL”˜â»ß$Ì6
é:¼t,nRµãNí±Èc’ÎQJ¬EñÙåTµå³«^·G»-–‡BÏ@B{RÍ8šÂ&[¶?\SÀoÇ“8=’ÒşéZ´Ğ°“^"Ï@ªª¯©µ".Ò©CX51Tİ½k/8Å¶;×¬¾"IéÜ6KmªG’` «h¿>Nr`st“¡º3×+ƒÂ¹v—-Nµ”8aÍ½‰-6ãÄè-Ù1$Qéjp†¦6òßkÕB:<¨n>‰¹Á¥Š$ºÅhîá¶ÌC¾Šß!²ñZ­_Q½ˆ›Â°Ø¥•7—ÕÇ´Ò«‡Šà»kK¹,¼—Œ¤à¸+|¹Ù_}šo}wµr7åF\‚;ÖîäŸÈ§‰!Qu…+x’ó2”¤(}â¢éAAzßüÛW¶WJa@ê‘E~ã5$E”jxT¯šÍ.u^ä"³„ÌÅ°.hF·ğ%Ø·\õâ¼ ñ“)çáuœ•ziÖ»Zd™ƒéÁÖ»“é–cÏv,ò›0å»Hñ›çæx6äšD(ÎÃÊYn˜HŠNKÛì[[«fBª¤ø}q…Œ¹ŞŠ±7¤¿Ÿ¢i˜/€O½“™m€eø	û}IÃ™&îUfé/øfÉÊTŠbfÇDqVÛê>…Y…|WUBÓwl-Ì‚0ò¬+ŒEmåÊÔÂßm‚å#Ót»àÖÌ¸‹<êÅ	}?©pÈ{Q¿JJÂ×HéoA!qs	¨Ñÿ/Ìú°?ÙFâFRÁ/™V!òF&TRÚøÙ©«ÚúØ„µØæA£ÍéÙ+"6”Aˆôc¿ïÅeû‹1~åRÅd©”@ÙšY=Â©SI½š¢2Ñ®0MzÙ€®@àŒÀÕTèü¤²ø°ë^ß<²ƒÜmùşœG¥8ÏKHp@K§Ô ½Ù$u^›KĞmg%œ$UMÚ‰ØŞ¨ı½6	­•œo¨ÊsŠ2˜ä@İàr§ÔD¸eVèKRÏkÊÜç/2Ã±}Üğ–‘%ôQZ‘‹trİ+1ZË´±ªæİî€â“şáËQ‹ä-:L÷Nóê 7fK9¥ã§£3ÓıäGÎÒ½C2â%í[†(2X)&¼˜-rÌCÎê4¤'hŸ5Döşà|Ïî¿¶º©()€/TPOşwWz‚xÊ©M“p5”<õ;İÀH_Ü&üè×Ú¶c6'İt1iqnX¼òÖwW˜²pàùxÉ7q_Ô&~†pbçê’~rüèKU¹âºËŸ ‚W·“Áëıkòvøg&”ù¦w-qĞœGımg¾¤IÉI·W,™kWÌPè<I3¯«@¡”#Ş	U”H]Ô¿fóµ.Ãô­—í•².±¥Ø¢›®î9í†)j­õv\¤]´pe”JâqY­øÎ€
éâñA_z7¿o’3ÄÅ-SâdÉëQÒ÷o“ÛÛÛ×¦ã`“ÍšQÃ>"Í]„2jjàĞ`CZO_´Ò#E“sN‡»+©?¹iÚ(eò òéM†;Y	Wj¶DZšN;hÔşÒºÜ§Á4ı¤ÌÑ™E7¢­j”à=j/±¤ŠÉ}A(l1t)Àı®îÆÍlh¹rD.ÂÔ»qJš4"ÃH™É½ï‡iŞï=Hí´Æ¢ŒXªGâš&ØÕ¹U‘xädƒÁcE¶^cò2ÔóMŒ`¯ô.×-ŸœîtùØê®‡Âq÷›2 ©^àâÈw‚{}¸q?UÖG´Î#*ğ$Hı¹UIœãJDö9àF75Î+ñƒß¼ºŒ1ãR[ÜºDé€9.ÀtHATõïÀ3å–3ƒ-ûñ§P-ø´€Ô¨^­B>Ë³[áƒİßšOı{G!Â a©s;p3/s©Á¾åñÇO¯¼avö¼Õ™C}bg†¸ôò'¢ÀEÏ—x~„RmÚ?Ş-=²âSÛıoâÜË:"ÂÍìIA3äÔ[}‰ï!EŒµ‰©°o÷IÍRş ˜5>úJìoW®²lˆ×•Ù¢ Jí®7uÙ¥jˆx8TdVt]pDá;#nÃIçŠ°ô>ÑÍ™(Ê«
QškšÄğ
Õ+‡¦ï¿àÌN[”`ŒÉ8árQ˜M^t“xÊĞb3MEã¯gòó2ã¯îğélàª"fü—æ‚¬Ğ½gÎ)£2[Ñ_éÌ˜øVÛY-el5EH(d^Cü2‘šMıß!pæ²$lÇd«y.Ğ™~$xcZv{PŠ“z×PF®‚»K"ÓÕ#EÚ"åIEL™†Ò”cœñ7`£ßÃ?ÁËb‚S.R#fàË`ãÊãØÖC|ĞJF_"~#‚ú§à·P]EÚØ»Ë”D²Ÿ	¯R¤§}õ\g¿TO2m¼YHÂå’)T“!²VUçÂÿ‘ÄLŠ'hìt$Sãê©Zë	©,))CİEºeT¡” şÍGíb_É¥nK[‰ß‘N˜ÀÚOìËÚ÷Nß´Ùˆæ°›9{dl-¹éë™¡úíËìøõz&{™¨EX£û5¥„h½SöïÈ§_·T«›Ñ)\éRII1b×3™´Ğö²	¨‡û2JM_6 î]Uù;Q³TÔx÷˜´%‹²"4c¼túµ&İÿy!±¿=)±<ŠDmÍFcOGÑF#«=A$'"L|õû“•±dC îº1‹—Ôv¹Ìr[EvL°g¼JRŞ2T6šR¶…^¸LT„q“æ÷ÏXöe)~Lk¡²Å>†tB3#6I%)¡‰ˆ<íÑ»ê¶uŒÅ½•$$:'ÍBá9Âosgç¤ˆVLFTó$İGõ¿÷’øŞlN¨GïWHBDòÖüô¨‘àó¿b'sé.9sOŸzÌÎNL=sßdH©íe)&š¬ÀJ	fæù:ƒE…Xî$?Um•‚´ş›ÈY‚Ÿ'_Ú—À~.G»ƒö@A?E©Ô¼(}ZajÆã~—?º	‘#}–=şßb’§\…Ÿ¨äõ1WÈÒ	‡M'½xÕ½R
´÷§ãµ(k¥«¼ğ(×Ë™Z¶5j_€"©‰fJ†VÌ‰óxÓ‹ºD¬7S/$BñPÌ@¿ÎÁ.ÙĞİ`'‰Ğ·ß\3$£‘+;1´)fÑk
åå6Èòc•Qe^=”Ê*ÇõòåÏ\FÛ‰íÉÚx0ÒÛú™HMä"¦Ä/Š¶ÒÀR¹5T‰8ÄP¢‚PPx÷Ñˆ0P3Sgl4o¬OªîÇãš¸D«çÔ_é¯ÓG a^ˆªæmËŸù†!Àõ4gÆWÎl†CÙšó«IC(¥M”ì!InZ-KEÕRL7q [÷À#»“›$FG5E^²,Õä¯é¡cş5¬:Tí"ş32“Qş7XÇ]ãk¡Ôƒ&b«‘nv„=¢!‘y,<¤á‹üyo¨’&øôƒè6e²/wõ&q©³ŸäXsİ¡ÕLĞIPÍ6ƒ}-2Òô#XFA®€$ØÖÖZ…hëÎÈÄú²»6Ú„ë]ê·‡nĞÀuR¢ºÉZF•2^{PŒ«Bæ†İ›5¤–.'æg™a6*hÊC×û~nşá1"u6nl1·–€ƒ:à®~ô	ó#\Ö˜¹¾<ÍŠèh*w“4RüßîIJ{ÀğšU£…íq™Í¬^­€:#WZºéUİÑYzˆD”lì{‰èÓŸ>ÄĞWgùßá´ÇKJtV±…Zvo&œ¡,NA\†¶VA>wµØãWÿ&}J.¶˜S¶B°ÚfyG„;Æ…z »&²u]6T•øÍúü±—1ıKçÓœ!¢ -|oEÌd˜UëŠ8ED*’“|F,!ºoÓõ{PJ+y‰N«­ªJ!$‰}Œ÷ÍBSşÅûµàP}©	Í`ºª6ûyïåÔjÜ‹W¨„ÇŠ~¹™ôWù—£#Õ”X‰	o9æ™êS.ò…ÖZ;ÿ½Æ±0ŠÿÈŸdış¢¤zªÈš4õ8×Hü£Kç(v:íTV‚’¾¶¶T–.Šî¹›®yÛ,E®3 °3’j%è_ï“L!¾æ| ‰Ÿ:z!zì²ğùBiØˆÂÖÕô©	»™òt1[c²Iï5'§}½MrğG÷àoëFß€"®$³!r6ß¡ov]bÒIœ]%Hthö©Šº?ˆKªìq‘a7ÉzûkÖ’±N—üÑ¼¬ZèïĞuû"èÕÇÑè__2Zš€d[½«[ØV›ô«RĞ‰"Y5«²Cir.ûnXjTŸğDT!™İŒ¦ÕSš•Ğù†É•az1ó~6Ç
²ö¢Zöîm¾[I,á>1ïáêNcßJ#›ï¾Ó>éí jÔk=|B!¼ê)Õ	Në’Ã^IŞ™Ğ¥J$øèb6}-˜M•Î¦-[”¬ZK/¡¾bñ-SX+<ÿU¸äªÔ}ùØX=–>8‚ãÑ´°Éõ¢fWõ:ÁjŠÔÃdF¨É™ºğÿnÎ/¢è{FÃĞ–ôÈH_.ÂÌ¥•z0³gŸ¨¶¾,˜gs¶‰##lĞL¯†üí¿ÜŠç‹rc òW.ÅKQx’?V†ZÚ˜ì¤¸Æ–R›,{Î*‡–3‚TC\=/d"Ç€¹“‰ÜW†F\ÂˆÁQK›‰a¹¡|¨Ïq¸ÅJåô^†å‹!ÒBš”~17ëŒÀÆ}²dqwO"Q3£Ä¬ºšÈmbq<ì¸r9×(½´&ÈÍ­~
$¸CNIrÖªqŞ‘IÌ	{¸„Ü('
İf18!oîÇPÁÿ2R?Ak8ş«ëÂ‰V¿¸4EÍéËï&æFRÇlŠN´
¨iP½¦>z®¦Ú»_%±IõB •ìÛäQEiä™yb|bØw’çˆi··S6RûØTƒáã\´®Ó6üFPö©£©š¸ãWUHZG1Î÷SB@ÿ¨Ÿ‘ß—¬yÂ,éúªZ“Wˆ( ŞyËÖ½^	sÃ~7÷'wı<&/M{îÈ.$'÷­ÃéïVë>ÉR*lÿ½¦/Ğ-
eWÚ¶çVñ@—IêzBièÓG›K¤&:‘UEjzàOø—ŠıÆßó š/¥£´üSÿssAıdñtœmô²š„u	Ù>?è"`S~§›¨èïA­q'İd`ó`ˆRnnš.‘3ùú x_<‘°\™M¡¿¿tqş•—v¥û B°iéÙ›ájH»Üéªoe•Ê°êJ3êD!y•\ôo‘Ç‘éí	|#òÌ}¢Ãéé¨LÉé«©õı/ßÏZµ½ÛDû$_C°ëL‹À²æXõ|P€µÈƒ”BÀnàEÂİI,²»®×Qœºg$CN”H~ÕzÛlrñ›·²GŠLİjÏì)e1Úƒ%áTy"ğÅÃ@¾ş™qmö˜¯‹`İ^Ó†;?ÍÎƒ§óq™^	j¿=<Ò¶Zpç§&Ø;
m{İó­´zËŠ%zr$½Ø2”SN×İK8_şÆÄ„˜û¾º(µµ†˜Q³nÆÿ[ìÁøôöÜ­×,úĞ?V´±Ç‹Ë×fŠFŞ$€·.PQP–U‹¡ÿù¨mû€¬uä zXNÃ€J EÊğı÷Ê³Š_æ„0+ÌMnìkĞõ‘«æCŸZ;C	IxOÒ´ğ²	g3Çªê½}êÍ¹Ú0k~oÑß§ó<Áé½¹Öƒne^°}¤½Ü=«^W÷»yjÑîqµ,S°G7¿÷ü/W†{kß…öøÍ.ÿ{®N¤×tø°v¥"Õ_¡E=ÕğÖï‰Tuö6ß'‰#]´¡]µ]".D.U)QoWŸPlı¬Ğ]NoóË2mÑ‹eDŠ=Èö9oJF–Š¼1Í	œ{´.+QÀÊàØb>&¹9$çšƒ™³#ß£´§›Qz›å=rÒªaRRTw?Kã{rşJ°<Ÿ6øÏUHÍ³âça?ĞqxÌ2±8S´A)şša„şıjy}Tª¸Ø>„S{išÇa¨¬ˆƒÊIì c©Œ4ñA‘!mÉCL_l{©8›#Ğó:@m=í³Ê‚˜‹’D[ûp#~Ö‹*à„©îÛ\+1+×z1*2êl÷G†k_>Á¢•Æ"_rí5¼â»G…Éqü^ârTZòo–ÓÔbï»8Qm¤¯r't,¬U½PBo•J¡Gµ‹˜ğ;u^?Š­˜¶Ï¤V4×(^nƒ€$Û‘DÚ5ÉÕ-$¹ü&å\¡HT5P¨<ÍÖæJ§Uexz†®ıÑ6ñŠƒ¢áÕäJ?}“&f”Ê Ø#sÒR.QĞM¤–L“}ÊÈÓwMŒØŠÒ+õPÜ®S1ˆ½O¦OŒ.Ö‹|’æ„kçr(âb$µ(ŸE§uw¥)”ûó6Úc’ü&ö‡vEM¸’R‘pl:JS3t¥IQrÊ{l#m¹ô·¥ä[øÓ¦§ñá©™}ê¯DXdó¤hJ”ÔHÀa´ªèW\g«çR—•è>»Ó×ÆW>Â“*)FüX,öÀ²(ZË&=Ó˜•ñ>ŸwÓñö(×Y|ìZ~VĞkÖ¥%ì66zd§Š„2êN3¸ëÉãó-ò½	]4Î‹F!õ¥Ò¥°Qı˜	0¼×¥ñòRË¼­¢Å×ÇÎà>¦
ÑIJuØÌãFJ{ZÓsÇíÈZ†›º³îËZ h·˜Úï‡Ó}»Ç&ïU^ÂG|÷ß¥©õ¼
fè†vYâêéš¦ráù<²xâ/™$ŞV×¼ìÊÔĞmEmz¤±6¥•Úg’®å
¡eß`µU_¹ì—¼bM-3Î4µ¢…Ò…¾áe'PDµj¯Wƒèbß1Œ^)Ö<¿óZ0jß átÊß¸ÍŒõ®?®Y…| ç3\ÖÔçA§’º
âC÷‹a¯†bôs¥ö@»¤Ó$›“Tô9u©ÚF¥îéöLí6S@¯Ïpûõ­]hõ!Ûs1ı½cÅ^ûv= ê ÀF°¹e