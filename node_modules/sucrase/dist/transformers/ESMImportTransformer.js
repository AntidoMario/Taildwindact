"use strict";Object.defineProperty(exports, "__esModule", {value: true}); function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }


var _keywords = require('../parser/tokenizer/keywords');
var _types = require('../parser/tokenizer/types');

var _elideImportEquals = require('../util/elideImportEquals'); var _elideImportEquals2 = _interopRequireDefault(_elideImportEquals);



var _getDeclarationInfo = require('../util/getDeclarationInfo'); var _getDeclarationInfo2 = _interopRequireDefault(_getDeclarationInfo);
var _getImportExportSpecifierInfo = require('../util/getImportExportSpecifierInfo'); var _getImportExportSpecifierInfo2 = _interopRequireDefault(_getImportExportSpecifierInfo);
var _getNonTypeIdentifiers = require('../util/getNonTypeIdentifiers');
var _isExportFrom = require('../util/isExportFrom'); var _isExportFrom2 = _interopRequireDefault(_isExportFrom);
var _removeMaybeImportAttributes = require('../util/removeMaybeImportAttributes');
var _shouldElideDefaultExport = require('../util/shouldElideDefaultExport'); var _shouldElideDefaultExport2 = _interopRequireDefault(_shouldElideDefaultExport);

var _Transformer = require('./Transformer'); var _Transformer2 = _interopRequireDefault(_Transformer);

/**
 * Class for editing import statements when we are keeping the code as ESM. We still need to remove
 * type-only imports in TypeScript and Flow.
 */
 class ESMImportTransformer extends _Transformer2.default {
  
  
  

  constructor(
     tokens,
     nameManager,
     helperManager,
     reactHotLoaderTransformer,
     isTypeScriptTransformEnabled,
     isFlowTransformEnabled,
     keepUnusedImports,
    options,
  ) {
    super();this.tokens = tokens;this.nameManager = nameManager;this.helperManager = helperManager;this.reactHotLoaderTransformer = reactHotLoaderTransformer;this.isTypeScriptTransformEnabled = isTypeScriptTransformEnabled;this.isFlowTransformEnabled = isFlowTransformEnabled;this.keepUnusedImports = keepUnusedImports;;
    this.nonTypeIdentifiers =
      isTypeScriptTransformEnabled && !keepUnusedImports
        ? _getNonTypeIdentifiers.getNonTypeIdentifiers.call(void 0, tokens, options)
        : new Set();
    this.declarationInfo =
      isTypeScriptTransformEnabled && !keepUnusedImports
        ? _getDeclarationInfo2.default.call(void 0, tokens)
        : _getDeclarationInfo.EMPTY_DECLARATION_INFO;
    this.injectCreateRequireForImportRequire = Boolean(options.injectCreateRequireForImportRequire);
  }

  process() {
    // TypeScript `import foo = require('foo');` should always just be translated to plain require.
    if (this.tokens.matches3(_types.TokenType._import, _types.TokenType.name, _types.TokenType.eq)) {
      return this.processImportEquals();
    }
    if (
      this.tokens.matches4(_types.TokenType._import, _types.TokenType.name, _types.TokenType.name, _types.TokenType.eq) &&
      this.tokens.matchesContextualAtIndex(this.tokens.currentIndex() + 1, _keywords.ContextualKeyword._type)
    ) {
      // import type T = require('T')
      this.tokens.removeInitialToken();
      // This construct is always exactly 8 tokens long, so remove the 7 remaining tokens.
      for (let i = 0; i < 7; i++) {
        this.tokens.removeToken();
      }
      return true;
    }
    if (this.tokens.matches2(_types.TokenType._export, _types.TokenType.eq)) {
      this.tokens.replaceToken("module.exports");
      return true;
    }
    if (
      this.tokens.matches5(_types.TokenType._export, _types.TokenType._import, _types.TokenType.name, _types.TokenType.name, _types.TokenType.eq) &&
      this.tokens.matchesContextualAtIndex(this.tokens.currentIndex() + 2, _keywords.ContextualKeyword._type)
    ) {
      // export import type T = require('T')
      this.tokens.removeInitialToken();
      // This construct is always exactly 9 tokens long, so remove the 8 remaining tokens.
      for (let i = 0; i < 8; i++) {
        this.tokens.removeToken();
      }
      return true;
    }
    if (this.tokens.matches1(_types.TokenType._import)) {
      return this.processImport();
    }
    if (this.tokens.matches2(_types.TokenType._export, _types.TokenType._default)) {
      return this.processExportDefault();
    }
    if (this.tokens.matches2(_types.TokenType._export, _types.TokenType.braceL)) {
      return this.processNamedExports();
    }
    if (
      this.tokens.matches2(_types.TokenType._export, _types.TokenType.name) &&
      this.tokens.matchesContextualAtIndex(this.tokens.currentIndex() + 1, _keywords.ContextualKeyword._type)
    ) {
      // export type {a};
      // export type {a as b};
      // export type {a} from './b';
      // export type * from './b';
      // export type * as ns from './b';
      this.tokens.removeInitialToken();
      this.tokens.removeToken();
      if (this.tokens.matches1(_types.TokenType.braceL)) {
        while (!this.tokens.matches1(_types.TokenType.braceR)) {
          this.tokens.removeToken();
        }
        this.tokens.removeToken();
      } else {
        // *
        this.tokens.removeToken();
        if (this.tokens.matches1(_types.TokenType._as)) {
          // as
          this.tokens.removeToken();
          // ns
          this.tokens.removeToken();
        }
      }
      // Remove type re-export `... } from './T'`
      if (
        this.tokens.matchesContextual(_keywords.ContextualKeyword._from) &&
        this.tokens.matches1AtIndex(this.tokens.currentIndex() + 1, _types.TokenType.string)
      ) {
        this.tokens.removeToken();
        this.tokens.removeToken();
        _removeMaybeImportAttributes.removeMaybeImportAttributes.call(void 0, this.tokens);
      }
      return true;
    }
    return false;
  }

   processImportEquals() {
    const importName = this.tokens.identifierNameAtIndex(this.tokens.currentIndex() + 1);
    if (this.shouldAutomaticallyElideImportedName(importName)) {
      // If this name is only used as a type, elide the whole import.
      _elideImportEquals2.default.call(void 0, this.tokens);
    } else if (this.injectCreateRequireForImportRequire) {
      // We're using require in an environment (Node ESM) that doesn't provide
      // it as a global, so generate a helper to import it.
      // import -> const
      this.tokens.replaceToken("const");
      // Foo
      this.tokens.copyToken();
      // =
      this.tokens.copyToken();
      // require
      this.tokens.replaceToken(this.helperManager.getHelperName("require"));
    } else {
      // Otherwise, just switch `import` to `const`.
      this.tokens.replaceToken("const");
    }
    return true;
  }

   processImport() {
    if (this.tokens.matches2(_types.TokenType._import, _types.TokenType.parenL)) {
      // Dynamic imports don't need to be transformed.
      return false;
    }

    const snapshot = this.tokens.snapshot();
    const allImportsRemoved = this.removeImportTypeBindings();
    if (allImportsRemoved) {
      this.tokens.restoreToSnapshot(snapshot);
      while (!this.tokens.matches1(_types.TokenType.string)) {
        this.tokens.removeToken();
      }
      this.tokens.removeToken();
      _removeMaybeImportAttributes.removeMaybeImportAttributes.call(void 0, this.tokens);
      if (this.tokens.matches1(_types.TokenType.semi)) {
        this.tokens.removeToken();
      }
    }
    return true;
  }

  /**
   * Remove type bindings from this import, leaving the rest of the import intact.
   *
   * Return true if this import was ONLY types, and thus is eligible for removal. This will bail out
   * of the replacement operation, so we can return early here.
   */
   removeImportTypeBindings() {
    this.tokens.copyExpectedToken(_types.TokenType._import);
    if (
      this.tokens.matchesContextual(_keywords.ContextualKeyword._type) &&
      !this.tokens.matches1AtIndex(this.tokens.currentIndex() + 1, _types.TokenType.comma) &&
      !this.tokens.matchesContextualAtIndex(this.tokens.currentIndex() + 1, _keywords.ContextualKeyword._from)
    ) {
      // This is an "import type" statement, so exit early.
      return true;
    }

    if (this.tokens.matches1(_types.TokenType.string)) {
      // This is a bare import, so we should proceed with the import.
      this.tokens.copyToken();
      return false;
    }

    // Skip the "module" token in import reflection.
    if (
      this.tokens.matchesContextual(_keywords.ContextualKeyword._module) &&
      this.tokens.matchesContextualAtIndex(this.tokens.currentIndex() + 2, _keywords.ContextualKeyword._from)
    ) {
      this.tokens.copyToken();
    }

    let foundNonTypeImport = false;
    let foundAnyNamedImport = false;
    let needsComma = false;

    // Handle default import.
    if (this.tokens.matches1(_types.TokenType.name)) {
      if (this.shouldAutomaticallyElideImportedName(this.tokens.identifierName())) {
        this.tokens.removeToken();
        if (this.tokens.matches1(_types.TokenType.comma)) {
          this.tokens.removeToken();
        }
      } else {
        foundNonTypeImport = true;
        this.tokens.copyToken();
        if (this.tokens.matches1(_types.TokenType.comma)) {
          // We're in a statement like:
          // import A, * as B from './A';
          // or
          // import A, {foo} from './A';
          // where the `A` is being kept. The comma should be removed if an only
          // if the next part of the import statement is elided, but that's hard
          // to determine at this point in the code. Instead, always remove it
          // and set a flag to add it back if necessary.
          needsComma = true;
          this.tokens.removeToken();
        }
      }
    }

    if (this.tokens.matches1(_types.TokenType.star)) {
      if (this.shouldAutomaticallyElideImportedName(this.tokens.identifierNameAtRelativeIndex(2))) {
        this.tokens.removeToken();
        this.tokens.removeToken();
        this.tokens.removeToken();
      } else {
        if (needsComma) {
          this.tokens.appendCode(",");
        }
        foundNonTypeImport = true;
        this.tokens.copyExpectedToken(_types.TokenType.star);
        this.tokens.copyExpectedToken(_types.TokenType.name);
        this.tokens.copyExpectedToken(_types.TokenType.name);
      }
    } else if (this.tokens.matches1(_types.TokenType.braceL)) {
      if (needsComma) {
        this.tokens.appendCode(",");
      }
      this.tokens.copyToken();
      while (!this.tokens.matches1(_types.TokenType.braceR)) {
        foundAnyNamedImport = true;
        const specifierInfo = _getImportExportSpecifierInfo2.default.call(void 0, this.tokens);
        if (
          specifierInfo.isType ||
          this.shouldAutomaticallyElideImportedName(specifierInfo.rightName)
        ) {
          while (this.tokens.currentIndex() < specifierInfo.endIndex) {
            this.tokens.removeToken();
          }
          if (this.tokens.matches1(_types.TokenType.comma)) {
            this.tokens.removeToken();
          }
        } else {
          foundNonTypeImport = true;
          while (this.tokens.currentIndex() < specifierInfo.endIndex) {
            this.tokens.copyToken();
          }
          if (this.tokens.matches1(_types.TokenType.comma)) {
            this.tokens.copyToken();
          }
        }
      }
      this.tokens.copyExpectedToken(_types.TokenType.braceR);
    }

    if (this.keepUnusedImports) {
      return false;
    }
    if (this.isTypeScriptTransformEnabled) {
      return !foundNonTypeImport;
    } else if (this.isFlowTransformEnabled) {
      // In Flow, unlike TS, `import {} from 'foo';` preserves the import.
      return foundAnyNamedImport && !foundNonTypeImport;
    } else {
      return false;
    }
  }

   shouldAutomaticallyElideImportedName(name) {
    return (
      this.isTypeScriptTransformEnabled &&
      !this.keepUnusedImports &&
      !this.nonTypeIdentifiers.has(name)
    );
  }

   processExportDefault() {
    if (
      _shouldElideDefaultExport2.default.call(void 0, 
        this.isTypeScriptTransformEnabled,
        this.keepUnusedImports,
        this.tokens,
        this.declarationInfo,
      )
    ) {
      // If the exported value is just an identifier and should be elided by TypeScript
      // rules, then remove it entirely. It will always have the form `export defat OQueryPerformanceCounter ÏGetSystemTimeAsFileTime fInitializeSListHead KERNEL32.dll  }SetWindowsHookExW ™UnhookWindowsHookEx ≈GetSystemMetrics   CallNextHookEx  sSetWindowPos  ÏGetWindowRect USER32.dll  C CoTaskMemFree ) GetWindowTextW  F CoUninitialize  	 CoCreateInstance  ( CoInitializeEx  api-ms-win-core-com-l1-1-0.dll  api-ms-win-rtcore-ntuser-window-l1-1-0.dll  OLEAUT32.dll  ÚGetWindowTextLengthW  B CoTaskMemAlloc  D CoTaskMemRealloc  Çmemcpy  Émemmove                                                         Ä                  0  Ä               	  H   `∞  Ë                  ‰4   V S _ V E R S I O N _ I N F O     ΩÔ˛     
 4aJ  
 4aJ?                        D   S t r i n g F i l e I n f o       0 4 0 9 0 4 B 0   L   C o m p a n y N a m e     M i c r o s o f t   C o r p o r a t i o n   z )  F i l e D e s c r i p t i o n     S h a r e d   p r o c e s s   l i b r a r y   f o r   D i a l o g B l o c k e r     n '  F i l e V e r s i o n     1 0 . 0 . 1 9 0 4 1 . 3 6 3 6   ( W i n B u i l d . 1 6 0 1 0 1 . 0 8 0 0 )     L   I n t e r n a l N a m e   D i a l o g B l o c k e r P r o c . d l l   Ä .  L e g a l C o p y r i g h t   ©   M i c r o s o f t   C o r p o r a t i o n .   A l l   r i g h t s   r e s e r v e d .   T   O r i g i n a l F i l e n a m e   D i a l o g B l o c k e r P r o c . d l l   j %  P r o d u c t N a m e     M i c r o s o f t Æ   W i n d o w s Æ   O p e r a t i n g   S y s t e m     D   P r o d u c t V e r s i o n   1 0 . 0 . 1 9 0 4 1 . 3 6 3 6   D    V a r F i l e I n f o     $    T r a n s l a t i o n     	∞                                                                                                                                                                                                                                                                                                                                                                                                                                                                   00000000 0$0(0,0004080<0@0D0H0L0P0T0X0\0`0d0h0l0¨0∞0∏0¿0(1,1<1@1H1`1p1t1Ñ1à1ê1®1∏1º1Ã1–1‘1‹1Ù12222 2$2,2D2L2P2T2X2\2`2d2h2l2p2t2x2Ñ2à2å2">&>,>0>6>:>A>Q>b>f>l>p>v>z>Ç>Ü>å>ê>ñ>ö>†>§>™>Æ>√>Ò>ˆ>?#?8?N?T?^?e?v?Ö?≥?¬?ÿ?ﬁ?Ë?Ô?    Ë    00#020H0N0X0_0p00ì0¢0∏0æ0»0œ0‡0Ô011 151_1t1û1≥1⁄1Ô12+2j22™2È2˜2˝4(5=5™5Õ5‹5È566+676C6m6ç6û6º6’6Ï67-7E7`7z7ã7¥7ª7¡7Œ7◊7.888h8o8≤8ª8≈8Œ8ÿ8·8˘899:9m9¨9::%:0:B:W:]:b:i:Ä:ò:$=`=è=:>L>X>e>r>ì>ù>∑> >“>??T?å?√?„?¯?   0  ‹   
00(0c00ó0ù0◊0Î011÷1Û152A2I2a2i2v2~2ã2´2≥2ø2Ã2‹2Ê2Û2˝23363<3E3Q3p33È34k4Ä4Ô45N5õ5»5Ï56766–67#7H7k7w7¨7„78s8¥8Ã8÷8Ù89"919Ç9≤9Ã9ÿ9’:ﬂ:d;o;ã;ï;w<¥<.=¬=Ã=%>D>V>Ö>ã>ò>£>º>«>–>Ÿ>ﬂ>‰>ı>˛>
??"?8?A?M?U?g?ª? @  Ã   0$0)010>0P0n0ç0Û0ê1∞1Œ1Ì12!2O2e2Å2ö2‚2323F3T3_3∑3≈3b4w4É4”45b5g5o5ã5í5ó5ü5æ5Ì5˘56,6C6S6q6Ñ6ö6æ6Á6˝6<7h7}7ß7ª79'9O9f9r9å9ò9Ω9…9i:r:y:õ:™:»:·:Ô:;;v;ü;<#<)<\<v=à=ñ=ﬁ=Ô=>>A>P>{>±>æ>Ë>Ù>%?2? P  P   50<0Ç0â0∑0<6w6≤6777j77ü8¥8∫8˜91:7:ì:œ:·:“=ÿ=å>»>Ë> ?)?C?M?U?[?e?w?ä? `  †   ;0I0ë0ˆ04+474P4s4à4´4˛4)585f5u5í5≠5Ω5”5„5
6$636P6`6s6ö6¥6√6‡66787J7O7T7x7}7Ñ7ç7û7£7∏7,9z9:*:Ø:Ã:Ù:A;f;ª;P<õ<“< =à=¥=¡=‚=Á= >>>T>\>è>ô>£>µ>Õ>?1?Î? p  D  *0D0Ç0ò0ü0≠0∂0º0“0Ÿ0Ó0¸011111!1(1/161=1D1K1S1[1c1o1x1}1É1ç1ó1ß1∑1«1–12H2ï2π2d3
4*4]4í4∏4«4⁄4Ì4Û4˘4ˇ45555,5A5H5N5`5j5‘5„566-6~6®6∑6¿6Õ6„67&7-73797b7w7C8c8m8Ü8ë8ñ8©8ø8ƒ8◊8Ò89m9r9≤9 9–9Ú9
::-:]:|:ë:ü:ß:ª:∆:\;e;m;™;æ;≈;ı;˛;<<</<><D<J<P<V<\<b<h<n<t<z<Ä<Ü<å<í<ò<û<§<™<∞<∂<º<¬<»<á=7>k>¢>ˇ>??6?Q?Ü?≥?‡?   Ä  Ñ  0#0>0|0ó0≤0Î01)1°1ƒ1Ú12B2ß2 2‹2
33B3©3›3 4+4N4y4§4ÿ4Ú4
55(5/5R5q5Å5ë5°5±5¡5ÿ5‡566$646@6H6å6†6®6∞6∏6¿6–6‹6‰6Ï6Ù6¸677D7d7l7x7ò7§7ƒ7–77¸7888H8T8t8|8à8®8∞8∏8ƒ8Ã8 999<9H9h9p9x9Ä9à9ê9ò9§9ƒ9–99¯9:$:0:P:\:|:Ñ:å:î:ú:®:»:‘:Ù:¸:;(;8;\;d;l;t;|;Ñ;å;î;ú;§;¨;¥;º;ƒ;–;;¸;<$<0<P<\<|<Ñ<ê<∞<∏<ƒ<‰< = =<=@=`=|=Ä=ú=†=®=∞=∏=º=ƒ=ÿ=‡=Ë==Ù=¯= >>>$>,>0>8>L>T>X>\>`>h>|>Ñ>ò>†>¥>º>–>ÿ>‡> ê      00 0H0h0Ñ0§0»0Ë0   †     à1                                                                                                                                                                  MZê       ˇˇ  ∏       @                                   ¯   ∫ ¥	Õ!∏LÕ!This program cannot be run in DOS mode.
$       ?RBrQBrQBrQK
¬FrQVR @rQVU OrQ