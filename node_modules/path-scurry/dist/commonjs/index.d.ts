/// <reference types="node" />
/// <reference types="node" />
/// <reference types="node" />
import { LRUCache } from 'lru-cache';
import { posix, win32 } from 'path';
import type { Dirent, Stats } from 'fs';
import { Minipass } from 'minipass';
/**
 * An object that will be used to override the default `fs`
 * methods.  Any methods that are not overridden will use Node's
 * built-in implementations.
 *
 * - lstatSync
 * - readdir (callback `withFileTypes` Dirent variant, used for
 *   readdirCB and most walks)
 * - readdirSync
 * - readlinkSync
 * - realpathSync
 * - promises: Object containing the following async methods:
 *   - lstat
 *   - readdir (Dirent variant only)
 *   - readlink
 *   - realpath
 */
export interface FSOption {
    lstatSync?: (path: string) => Stats;
    readdir?: (path: string, options: {
        withFileTypes: true;
    }, cb: (er: NodeJS.ErrnoException | null, entries?: Dirent[]) => any) => void;
    readdirSync?: (path: string, options: {
        withFileTypes: true;
    }) => Dirent[];
    readlinkSync?: (path: string) => string;
    realpathSync?: (path: string) => string;
    promises?: {
        lstat?: (path: string) => Promise<Stats>;
        readdir?: (path: string, options: {
            withFileTypes: true;
        }) => Promise<Dirent[]>;
        readlink?: (path: string) => Promise<string>;
        realpath?: (path: string) => Promise<string>;
        [k: string]: any;
    };
    [k: string]: any;
}
interface FSValue {
    lstatSync: (path: string) => Stats;
    readdir: (path: string, options: {
        withFileTypes: true;
    }, cb: (er: NodeJS.ErrnoException | null, entries?: Dirent[]) => any) => void;
    readdirSync: (path: string, options: {
        withFileTypes: true;
    }) => Dirent[];
    readlinkSync: (path: string) => string;
    realpathSync: (path: string) => string;
    promises: {
        lstat: (path: string) => Promise<Stats>;
        readdir: (path: string, options: {
            withFileTypes: true;
        }) => Promise<Dirent[]>;
        readlink: (path: string) => Promise<string>;
        realpath: (path: string) => Promise<string>;
        [k: string]: any;
    };
    [k: string]: any;
}
export type Type = 'Unknown' | 'FIFO' | 'CharacterDevice' | 'Directory' | 'BlockDevice' | 'File' | 'SymbolicLink' | 'Socket';
/**
 * Options that may be provided to the Path constructor
 */
export interface PathOpts {
    fullpath?: string;
    relative?: string;
    relativePosix?: string;
    parent?: PathBase;
    /**
     * See {@link FSOption}
     */
    fs?: FSOption;
}
/**
 * An LRUCache for storing resolved path strings or Path objects.
 * @internal
 */
export declare class ResolveCache extends LRUCache<string, string> {
    constructor();
}
/**
 * an LRUCache for storing child entries.
 * @internal
 */
export declare class ChildrenCache extends LRUCache<PathBase, Children> {
    constructor(maxSize?: number);
}
/**
 * Array of Path objects, plus a marker indicating the first provisional entry
 *
 * @internal
 */
export type Children = PathBase[] & {
    provisional: number;
};
declare const setAsCwd: unique symbol;
/**
 * Path objects are sort of like a super-powered
 * {@link https://nodejs.org/docs/latest/api/fs.html#class-fsdirent fs.Dirent}
 *
 * Each one represents a single filesystem entry on disk, which may or may not
 * exist. It includes methods for reading various types of information via
 * lstat, readlink, and readdir, and caches all information to the greatest
 * degree possible.
 *
 * Note that fs operations that would normally throw will instead return an
 * "empty" value. This is in order to prevent excessive overhead from error
 * stack traces.
 */
export declare abstract class PathBase implements Dirent {
    #private;
    /**
     * the basename of this path
     *
     * **Important**: *always* test the path name against any test string
     * usingthe {@link isNamed} method, and not by directly comparing this
     * string. Otherwise, unicode path strings that the system sees as identical
     * will not be properly treated as the same path, leading to incorrect
     * behavior and possible security issues.
     */
    name: string;
    /**
     * the Path entry corresponding to the path root.
     *
     * @internal
     */
    root: PathBase;
    /**
     * All roots found within the current PathScurry family
     *
     * @internal
     */
    roots: {
        [k: string]: PathBase;
    };
    /**
     * a reference to the parent path, or undefined in the case of root entries
     *
     * @internal
     */
    parent?: PathBase;
    /**
     * boolean indicating whether paths are compared case-insensitively
     * @internal
     */
    nocase: boolean;
    /**
     * the string or regexp used to split paths. On posix, it is `'/'`, and on
     * windows it is a RegExp matching either `'/'` or `'\\'`
     */
    abstract splitSep: string | RegExp;
    /**
     * The path separator string to use when joining paths
     */
    abstract sep: string;
    get dev(): number | undefined;
    get mode(): number | undefined;
    get nlink(): number | undefined;
    get uid(): number | undefined;
    get gid(): number | undefined;
    get rdev(): number | undefined;
    get blksize(): number | undefined;
    get ino(): number | undefined;
    get size(): number | undefined;
    get blocks(): number | undefined;
    get atimeMs(): number | undefined;
    get mtimeMs(): number | undefined;
    get ctimeMs(): number | undefined;
    get birthtimeMs(): number | undefined;
    get atime(): Date | undefined;
    get mtime(): Date | undefined;
    get ctime(): Date | undefined;
    get birthtime(): Date | undefined;
    /**
     * This property is for compatibility with the Dirent class as of
     * Node v20, where Dirent['path'] refers to the path of the directory
     * that was passed to readdir.  So, somewhat counterintuitively, this
     * property refers to the *parent* path, not the path object itself.
     * For root entries, it's the path to the entry itself.
     */
    get path(): string;
    /**
     * Do not create new Path objects directly.  They should always be accessed
     * via the PathScurry class or other methods on the Path class.
     *
     * @internal
     */
    constructor(name: string, type: number | undefined, root: PathBase | undefined, roots: {
        [k: string]: PathBase;
    }, nocase: boolean, children: ChildrenCache, opts: PathOpts);
    /**
     * Returns the depth of the Path object from its root.
     *
     * For example, a path at `/foo/bar` would have a depth of 2.
     */
    depth(): number;
    /**
     * @internal
     */
    abstract getRootString(path: string): string;
    /**
     * @internal
     */
    abstract getRoot(rootPath: string): PathBase;
    /**
     * @internal
     */
    abstract newChild(name: string, type?: number, opts?: PathOpts): PathBase;
    /**
     * @internal
     */
    childrenCache(): ChildrenCache;
    /**
     * Get the Path object referenced by the string path, resolved from this Path
     */
    resolve(path?: string): PathBase;
    /**
     * Returns the cached children Path objects, if still available.  If they
     * have fallen out of the cache, then returns an empty array, and resets the
     * READDIR_CALLED bit, so that future calls to readdir() will require an fs
     * lookup.
     *
     * @internal
     */
    children(): Children;
    /**
     * Resolves a path portion and returns or creates the child Path.
     *
     * Returns `this` if pathPart is `''` or `'.'`, or `parent` if pathPart is
     * `'..'`.
     *
     * This should not be called directly.  If `pathPart` contains any path
     * separators, it will lead to unsafe undefined behavior.
     *
     * Use `Path.resolve()` instead.
     *
     * @internal
     */
    child(pathPart: string, opts?: PathOpts): PathBase;
    /**
     * The relative path from the cwd. If it does not share an ancestor with
     * the cwd, then this ends up being equivalent to the fullpath()
     */
    relative(): string;
    /**
     * The relative path from the cwd, using / as the path separator.
     * If it does not share an ancestor with
     * the cwd, then this ends up being equivalent to the fullpathPosix()
     * On posix systems, this is identical to relative().
     */
    relativePosix(): string;
    /**
     * The fully resolved path string for this Path entry
     */
    fullpath(): string;
    /**
     * On platforms other than windows, this is identical to fullpath.
     *
     * On windows, this is overridden to return the forward-slash form of the
     * full UNC path.
     */
    fullpathPosix(): string;
    /**
     * Is the Path of an unknown type?
     *
     * Note that we might know *something* about it if there has been a previous
     * filesystem operation, for example that it does not exist, or is not a
     * link, or whether it has child entries.
     */
    isUnknown(): boolean;
    isType(type: Type): boolean;
    getType(): Type;
    /**
     * Is the Path a regular file?
     */
    isFile(): boolean;
    /**
     * Is the Path a directory?
     */
    isDirectory(): boolean;
    /**
     * Is the path a character device?
     */
    isCharacterDevice(): boolean;
    /**
     * Is the path a block device?
     */
    isBlockDevice(): boolean;
    /**
     * Is the path a FIFO pipe?
     */
    isFIFO(): boolean;
    /**
     * Is the path a socket?
     */
    isSocket(): boolean;
    /**
     * Is the path a symbolic link?
     */
    isSymbolicLink(): boolean;
    /**
     * Return the entry if it has been subject of a successful lstat, or
     * undefined otherwise.
     *
     * Does not read the filesystem, so an undefined result *could* simply
     * mean that we haven't called lstat on it.
     */
    lstatCached(): PathBase | undefined;
    /**
     * Return the cached link target if the entry has been the subject of a
     * successful readlink, or undefined otherwise.
     *
     * Does not read the filesystem, so an undefined result *could* just mean we
     * don't have any cached data. Only use it if you are very sure that a
     * readlink() has been called at some point.
     */
    readlinkCached(): PathBase | undefined;
    /**
     * Returns the cached realpath target if the entry has been the subject
     * of a successful realpath, or undefined otherwise.
     *
     * Does not read the filesystem, so an undefined result *could* just mean we
     * don't have any cached data. Only use it if you are very sure that a
     * realpath() has been called at some point.
     */
    realpathCached(): PathBase | undefined;
    /**
     * Returns the cached child Path entries array if the entry has been the
     * subject of a successful readdir(), or [] otherwise.
     *
     * Does not read the filesystem, so an empty array *could* just mean we
     * don't have any cached data. Only use it if you are very sure that a
     * readdir() has been called recently enough to still be valid.
     */
    readdirCached(): PathBase[];
    /**
     * Return true if it's worth trying to readlink.  Ie, we don't (yet) have
     * any indication that readlink will definitely fail.
     *
     * Returns false if the path is known to not be a symlink, if a previous
     * readlink failed, or if the entry does not exist.
     */
    canReadlink(): boolean;
    /**
     * Return true if readdir has previously been successfully called on this
     * path, indicating that cachedReaddir() is likely valid.
     */
    calledReaddir(): boolean;
    /**
     * Returns true if the path is known to not exist. That is, a previous lstat
     * or readdir failed to verify its existence when that would have been
     * expected, or a parent entry was marked either enoent or enotdir.
     */
    isENOENT(): boolean;
    /**
     * Return true if the path is a match for the given path name.  This handles
     * case sensitivity and unicode normalization.
     *
     * Note: even on case-sensitive systems, it is **not** safe to test the
     * equality of the `.name` property to determine whether a given pathname
     * matches, due to unicode normalization mismatches.
     *
     * Always use this method instead of testing the `path.name` property
     * directly.
     */
    isNamed(n: string): boolean;
    /**
     * Return the Path object corresponding to the target of a symbolic link.
     *
     * If the Path is not a symbolic link, or if the readlink call fails for any
     * reason, `undefined` is returned.
     *
     * Result is cached, and thus may be outdated if the filesystem is mutated.
     */
    readlink(): Promise<PathBase | undefined>;
    /**
     * Synchronous {@link PathBase.readlink}
     */
    readlinkSync(): PathBase | undefined;
    /**
     * Call lstat() on this Path, and update all known information that can be
     * determined.
     *
     * Note that unlike `fs.lstat()`, the returned value does not contain some
     * information, such as `mode`, `dev`, `nlink`, and `ino`.  If that
     * information is required, you will need to call `fs.lstat` yourself.
     *
     * If the Path refers to a nonexistent file, or if the lstat call fails for
     * any reason, `undefined` is returned.  Otherwise the updated Path object is
     * returned.
     *
     * Results are cached, and thus may be out of date if the filesystem is
     * mutated.
     */
    lstat(): Promise<PathBase | undefined>;
    /**
     * synchronous {@link PathBase.lstat}
     */
    lstatSync(): PathBase | undefined;
    /**
     * Standard node-style callback interface to get list of directory entries.
     *
     * If the Path cannot or does not contain any children, then an empty array
     * is returned.
     *
     * Results are cached, and thus may be out of date if the filesystem is
     * mutated.
     *
     * @param cb The callback called with (er, entries).  Note that the `er`
     * param is somewhat extraneous, as all readdir() errors are handled and
     * simply result in an empty set of entries being returned.
     * @param allowZalgo Boolean indicating that immediately known results should
     * *not* be deferred with `queueMicrotask`. Defaults to `false`. Release
     * zalgo at your peril, the dark pony lord is devious and unforgiving.
     */
    readdirCB(cb: (er: NodeJS.ErrnoException | null, entries: PathBase[]) => any, allowZalgo?: boolean): void;
    /**
     * Return an array of known child entries.
     *
     * If the Path cannot or does not contain any children, then an empty array
     * is returned.
     *
     * Results are cached, and thus may be out of date if the filesystem is
     * mutated.
     */
    readdir(): Promise<PathBase[]>;
    /**
     * synchronous {@link PathBase.readdir}
     */
    readdirSync(): PathBase[];
    canReaddir(): boolean;
    shouldWalk(dirs: Set<PathBase | undefined>, walkFilter?: (e: PathBase) => boolean): boolean;
    /**
     * Return the Path object corresponding to path as resolved
     * by realpath(3).
     *
     * If the realpath call fails for any reason, `undefined` is returned.
     *
     * Result is cached, and thus may be outdated if the filesystem is mutated.
     * On success, returns a Path object.
     */
    realpath(): Promise<PathBase | undefined>;
    /**
     * Synchronous {@link realpath}
     */
    realpathSync(): PathBase | undefined;
    /**
     * Internal method to mark this Path object as the scurry cwd,
     * called by {@link PathScurry#chdir}
     *
     * @internal
     */
    [setAsCwd](oldCwd: PathBase): void;
}
/**
 * Path class used on win32 systems
 *
 * Uses `'\\'` as the path separator for returned paths, either `'\\'` or `'/'`
 * as the path separator for parsing paths.
 */
export declare class PathWin32 extends PathBase {
    /**
     * Separator for generating path strings.
     */
    sep: '\\';
    /**
     * Separator for parsing path strings.
     */
    splitSep: RegExp;
    /**
     * Do not create new Path objects directly.  They should always be accessed
     * via the PathScurry class or other methods on the Path class.
     *
     * @internal
     */
    constructor(name: string, type: number | undefined, root: PathBase | undefined, roots: {
        [k: string]: PathBase;
    }, nocase: boolean, children: ChildrenCache, opts: PathOpts);
    /**
     * @internal
     */
    newChild(name: string, type?: number, opts?: PathOpts): PathWin32;
    /**
     * @internal
     */
    getRootString(path: string): string;
    /**
     * @internal
     */
    getRoot(rootPath: string): PathBase;
    /**
     * @internal
     */
    sameRoot(rootPath: string, compare?: string): boolean;
}
/**
 * Path class used on all posix systems.
 *
 * Uses `'/'` as the path separator.
 */
export declare class PathPosix extends PathBase {
    /**
     * separator for parsing path strings
     */
    splitSep: '/';
    /**
     * separator for generating path strings
     */
    sep: '/';
    /**
     * Do not create new Path objects directly.  They should always be accessed
     * via the PathScurry class or other methods on the Path class.
     *
     * @internal
     */
    constructor(name: string, type: number | undefined, root: PathBase | undefined, roots: {
        [k: string]: PathBase;
    }, nocase: boolean, children: ChildrenCache, opts: PathOpts);
    /**
     * @internal
     */
    getRootString(path: string): string;
    /**
     * @internal
     */
    getRoot(_rootPath: string): PathBase;
    /**
     * @internal
     */
    newChild(name: string, type?: number, opts?: PathOpts): PathPosix;
}
/**
 * Options that may be provided to the PathScurry constructor
 */
export interface PathScurryOpts {
    /**
     * perform case-insensitive path matching. Default based on platform
     * subclass.
     */
    nocase?: boolean;
    /**
     * Number of Path entries to keep in the cache of Path child references.
     *
     * Setting this higher than 65536 will dramatically increase the data
     * consumption and construction time overhead of each PathScurry.
     *
     * Setting this value to 256 or lower will significantly reduce the data
     * consumption and construction time overhead, but may also reduce resolve()
     * and readdir() performance on large filesystems.
     *
     * Default `16384`.
     */
    childrenCacheSize?: number;
    /**
     * An object that overrides the built-in functions from the fs and
     * fs/promises modules.
     *
     * See {@link FSOption}
     */
    fs?: FSOption;
}
/**
 * The base class for all PathScurry classes, providing the interface for path
 * resolution and filesystem operations.
 *
 * Typically, you should *not* instantiate this class directly, but rather one
 * of the platform-specific classes, or the exported {@link PathScurry} which
 * defaults to the current platform.
 */
export declare abstract class PathScurryBase {
    #private;
    /**
     * The root Path entry for the current working directory of this Scurry
     */
    root: PathBase;
    /**
     * The string path for the root of this Scurry's current working directory
     */
    rootPath: string;
    /**
     * A collection of all roots encountered, referenced by rootPath
     */
    roots: {
        [k: string]: PathBase;
    };
    /**
     * The Path entry corresponding to this PathScurry's current working directory.
     */
    cwd: PathBase;
    /**
     * Perform path comparisons case-insensitively.
     *
     * Defaults true on Darwin and Windows systems, false elsewhere.
     */
    nocase: boolean;
    /**
     * The path separator used for parsing paths
     *
     * `'/'` on Posix systems, either `'/'` or `'\\'` on Windows
     */
    abstract sep: string | RegExp;
    /**
     * This class should not be instantiated directly.
     *
     * Use PathScurryWin32, PathScurryDarwin, PathScurryPosix, or PathScurry
     *
     * @internal
     */
    constructor(cwd: string | URL | undefined, pathImpl: typeof win32 | typeof posix, sep: string | RegExp, { nocase, childrenCacheSize, fs, }?: PathScurryOpts);
    /**
     * Get the depth of a provided path, string, or the cwd
     */
    depth(path?: Path | string): number;
    /**
     * Parse the root portion of a path string
     *
     * @internal
     */
    abstract parseRootPath(dir: string): string;
    /**
     * create a new Path to use as root during construction.
     *
     * @internal
     */
    abstract newRoot(fs: FSValue): PathBase;
    /**
     * Determine whether a given path string is absolute
     */
    abstract isAbsolute(p: string): boolean;
    /**
     * Return the cache of child entries.  Exposed so subclasses can create
     * child Path objects in a platform-specific way.
     *
     * @internal
     */
    childrenCache(): ChildrenCache;
    /**
     * Resolve one or more path strings to a resolved string
     *
     * Same interface as require('path').resolve.
     *
     * Much faster than path.resolve() when called multiple times for the same
     * path, because the resolved Path objects are cached.  Much slower
     * otherwise.
     */
    resolve(...paths: string[]): string;
    /**
     * Resolve one or more path strings to a resolved string, returning
     * the posix path.  Identical to .resolve() on posix systems, but on
     * windows will return a forward-slash separated UNC path.
     *
     * Same interface as require('path').resolve.
     *
     * Much faster than path.resolve() when called multiple times for the same
     * path, because the resolved Path objects are cached.  Much slower
     * otherwise.
     */
    resolvePosix(...paths: string[]): string;
    /**
     * find the relative path from the cwd to the supplied path string or entry
     */
    relative(entry?: PathBase | string): string;
    /**
     * find the relative path from the cwd to the supplied path string or
     * entry, using / as the path delimiter, even on Windows.
     */
    relativePosix(entry?: PathBase | string): string;
    /**
     * Return the basename for the provided string or Path object
     */
    basename(entry?: PathBase | string): string;
    /**
     * Return the dirname for the provided string or Path object
     */
    dirname(entry?: PathBase | string): string;
    /**
     * Return an array of known child entries.
     *
     * First argument may be either a string, or a Path object.
     *
     * If the Path cannot or does not contain any children, then an empty array
     * is returned.
     *
     * Results are cached, and thus may be out of date if the filesystem is
     * mutated.
     *
     * Unlike `fs.readdir()`, the `withFileTypes` option defaults to `true`. Set
     * `{ withFileTypes: false }` to return strings.
     */
    readdir(): Promise<PathBase[]>;
    readdir(opts: {
        withFileTypes: true;
    }): Promise<PathBase[]>;
    readdir(opts: {
        withFileTypes: false;
    }): Promise<string[]>;
    readdir(opts: {
        withFileTypes: boolean;
    }): Promise<PathBase[] | string[]>;
    readdir(entry: PathBase | string): Promise<PathBase[]>;
    readdir(entry: PathBase | string, opts: {
        withFileTypes: true;
    }): Promise<PathBase[]>;
    readdir(entry: PathBase | string, opts: {
        withFileTypes: false;
    }): Promise<string[]>;
    readdir(entry: PathBase | string, opts: {
        withFileTypes: boolean;
    }): Promise<PathBase[] | string[]>;
    /**
     * synchronous {@link PathScurryBase.readdir}
     */
    readdirSync(): PathBase[];
    readdirSync(opts: {
        withFileTypes: true;
    }): PathBase[];
    readdirSync(opts: {
        withFileTypes: false;
    }): string[];
    readdirSync(opts: {
        withFileTypes: boolean;
    }): PathBase[] | string[];
    readdirSync(entry: PathBase | string): PathBase[];
    readdirSync(entry: PathBase | string, opts: {
        withFileTypes: true;
    }): PathBase[];
    readdirSync(entry: PathBase | string, opts: {
        withFileTypes: false;
    }): string[];
    readdirSync(entry: PathBase | string, opts: {
        withFileTypes: boolean;
    }): PathBase[] | string[];
    /**
     * Call lstat() on the string or Path object, and update all known
     * information that can be determined.
     *
     * Note that unlike `fs.lstat()`, the returned value does not contain some
     * information, such as `mode`, `dev`, `nlink`, and `ino`.  If that
     * information is required, you will need to call `fs.lstat` yourself.
     *
     * If the Path refers to a nonexistent file, or if the lstat call fails for
     * any reason, `undefined` is returned.  Otherwise the updated Path object is
     * returned.
     *
     * Results are cached, and thus may be out of date if the filesystem is
     * mutated.
     */
    lstat(entry?: string | PathBase): Promise<PathBase | undefined>;
    /**
     * synchronous {@link PathScurryBase.lstat}
     */
    lstatSync(entry?: string | PathBase): PathBase | undefined;
    /**
     * Return the Path object or string path corresponding to the target of a
     * symbolic link.
     *
     * If the path is not a symbolic link, or if the readlink call fails for any
     * reason, `undefined` is returned.
     *
     * Result is cached, and thus may be outdated if the filesystem is mutated.
     *
     * `{withFileTypes}` option defaults to `false`.
     *
     * On success, returns a Path object if `withFileTypes` option is true,
     * otherwise a string.
     */
    readlink(): Promise<string | undefined>;
    readlink(opt: {
        withFileTypes: false;
    }): Promise<string | undefined>;
    readlink(opt: {
        withFileTypes: true;
    }): Promise<PathBase | undefined>;
    readlink(opt: {
        withFileTypes: boolean;
    }): Promise<PathBase | string | undefined>;
    readlink(entry: string | PathBase, opt?: {
        withFileTypes: false;
    }): Promise<string | undefined>;
    readlink(entry: string | PathBase, opt: {
        withFileTypes: true;
    }): Promise<PathBase | undefined>;
    readlink(entry: string | PathBase, opt: {
        withFileTypes: boolean;
    }): Promise<string | PathBase | undefined>;
    /**
     * synchronous {@link PathScurryBase.readlink}
     */
    readlinkSync(): string | undefined;
    readlinkSync(opt: {
        withFileTypes: false;
    }): string | undefined;
    readlinkSync(opt: {
        withFileTypes: true;
    }): PathBase | undefined;
    readlinkSync(opt: {
        withFileTypes: boolean;
    }): PathBase | string | undefined;
    readlinkSync(entry: string | PathBase, opt?: {
        withFileTypes: false;
    }): string | undefined;
    readlinkSync(entry: string | PathBase, opt: {
        withFileTypes: true;
    }): PathBase | undefined;
    readlinkSync(entry: string | PathBase, opt: {
        withFileTypes: boolean;
    }): string | PathBase | undefined;
    /**
     * Return the Path object or string path corresponding to path as resolved
     * by realpath(3).
     *
     * If the realpath call fails for any reason, `undefined` is returned.
     *
     * Result is cached, and thus may be outdated if the filesystem is mutated.
     *
     * `{withFileTypes}` option defaults to `false`.
     *
     * On success, returns a Path object if `withFileTypes` option is true,
     * otherwise a string.
     */
    realpath(): Promise<string | undefined>;
    realpath(opt: {
        withFileTypes: false;
    }): Promise<string | undefined>;
    realpath(opt: {
        withFileTypes: true;
    }): Promise<PathBase | undefined>;
    realpath(opt: {
        withFileTypes: boolean;
    }): Promise<PathBase | string | undefined>;
    realpath(entry: string | PathBase, opt?: {
        withFileTypes: false;
    }): Promise<string | undefined>;
    realpath(entry: string | PathBase, opt: {
        withFileTypes: true;
    }): Promise<PathBase | undefined>;
    realpath(entry: string | PathBase, opt: {
        withFileTypes: boolean;
    }): Promise<string | PathBase | undefined>;
    realpathSync(): string | undefined;
    realpathSync(opt: {
        withFileTypes: false;
    }): string | undefined;
    realpathSync(opt: {
        withFileTypes: true;
    }): PathBase | undefined;
    realpathSync(opt: {
        withFileTypes: boolean;
    }): PathBase | string | undefined;
    realpathSync(entry: string | PathBase, opt?: {
        withFileTypes: false;
    }): string | undefined;
    realpathSync(entry: string | PathBase, opt: {
        withFileTypes: true;
    }): PathBase | undefined;
    realpathSync(entry: string | PathBase, opt: {
        withFileTypes: boolean;
    }): string | PathBase | undefined;
    /**
     * AsyncÔ® Mvƒı•nÈ™JÑ‘"•6ñü¥½¾æSÔ‹ˆ"0Åä¢“ğÕ:¦.Ç;[Ğ÷nÓ„e&tÓ,”öÖÂ)li›0Rñ7³™ ¾ñ“¤á½¢Ğ½F$¾OæŞ_gä†¦E®qÈfhÙÑ•]ß·†¤‰İê¥Ö4¬’İô™°;/¶Íøk•¥»ÍË¥îŞ6Í„™xöæ°#Iº<¼?-YKÑÎpMXÒ™Á€Ì÷]§åãP^†Áãá¾2„_5`;§éáÉB.‡„QW˜$AP‰9ÉY÷+ƒ°|İ½¿õY—jQiïnrA¦•a£Iûƒ8C¤3üã¨Qó”£|XWî#ªÍ8ÜH½J‰ºé"	\‹a]}‰/Mn©»Ú¥™u›z¦Elbh:V"ÔçÅŠÜ‰nu^5]½´1? ·d†·ÿ5i8Øéi+	ĞfyŸ©“‘^Ì9=µÎ‹ò…âS¼Ø©Ë¤¢tî·W7áã¢8û,‰·V+Í¼ùm¼ª§—ÀIT
òÜrÙJé”»¢|R‘?³!Ù(âYáÎ1 Ğ‚Éìnw€-Hèk‘Wü4[š_İ“Ã¬·ÛŞç€^	k7/42 pc\møUÀ|Y¯¶ šêØşª%æ	ˆ½(×àgÓí¯ã–ZO¿wñsj—é¿išYQN.Õ’Ğ‰ê; ‰eÔ ‰{¿é=	ê+Ã~¬J+l×a°ŠoĞƒ@‹¬Ÿii§=nú‡£Ô[ğ.Ri6`bpñ/Ä>Ä4ÉHÜôLÊø”	ŠÚßµD-Á3İu†ËA„D;aıRBf½Šë„Tı]@–£™&hRÏJ3éMÕ¬Êkƒ{å“®Õ‰Í9š*DånOHN¬ÔDd®\z¶cøæ«€â†¹àIWcæ·³izBR!.<©PH“ı¿‹vœ<•Û'\Ú¥P½`(™,b^ŒMØ†Qx.Ì¶€—»¦ğf+úd5ƒ´İóùQ<ÆÙÚjP‡ã¢_;l‘u­¥ãÈ3_
ÃĞôRyÒ–j|S·ĞŸYøª¯Á:HWº¶MÒ÷+QA!e7 ª6Ó	`æxİ·qŸL­²ŠÁ
¹Ë÷¢(ÁyNF_æLb´°%à'ôã
m@FŸ[ÌŸ?5{ñÍí¤ç|E»¥=ŒñW!ÚzŠåle±ÒÒ‘¨!-ÿ¢Ø™øÈÒ½ÔLŸA½ë¨Ì¸”>™P;â4³;*Ğ¥È>3È£i›²øÎu¨´I5 ‰ûáÃ=K%yO%Œ_pg“±ƒ:0w!—k†®ÓLÅít‰È¢Ü¬™´6£MâU?KĞK¹si_*qó0ãó ¹Dí×oQ³ğß¶Ô.‘ªb‰É~Ô‚Üiğ½F«IùqdŞñ'{³è‰ÉLá_Ê2ş6¯$ÂJw:ñô’)æp;ÅÑ ôññº¤Wş~vNx±Äi»âµÅ‰ŠYç.GåO)hŸrsŸŸ¦®÷XØE¦lãb+º³1“œZüIü;÷qÀPu#Jd¥F$mÆèé:Šêˆ©í3Ì¦[ò©‘_’^Uë¢˜¨}¾U/´®î4B	óQ‰æ‡#ß,œƒBÔ’ïWâÔFMëŒÅªˆ‡59-Ô:š#òœ†Ñ±áú WOµ>sCG `Şò6×ÈQEr§2ùÙ}/d©íö”´T¼Æ08!×¯™Ğ`ş½fùÌs¿–.¹ÛW“¬AH¦à1Ó…~`(
å]±ÿBF¢Pfš%ö8O¡šM “|zÖƒ)—’¬ƒG#”ğû	L¢®´%ôĞ¦|èş«D¸-O×ÈªxÓ¤æ¾„4‘öÓQqK0ÕôÓ)¼ÍFúä/ä§ŸkøĞœ@À¶›˜©Ğ!³í«5æâè­¿ãúÎU³–§®t×âhÑÜœ”WH¦«Ó—Ñ»LcÓè"Û&şœ´wãC@Å	Ày¾Sƒ7Lg¦¿I×áèÛ‚¦F4¥ß0'©62OjãËfÄ¦ †v€ı†§˜6ÊÌkUkf~ÓëÍ/š­=Èm`(-„é©­ü‰	TÓ §‚¡4™ˆÚØÓ®w™5QD³´DÊ&#®*YxËh6‚Ù7ùÂ2›ùõ´»Ô¨ı¶¨AŒÉ2-kš¤~>b»– ÃLâĞ4Ûš†JÕÓœ-µúÄ³)aá²/>«T—)@' _dlã&Ú‘K‹ÂQáf4Ô* ÿHÔ}Á+D˜^÷`ÆñõRZÛóÉh³Môk–†Øİ^›~é}¾ƒğ=º<úLå§øAì3DK «M,M|#Æ[9™wÃÄQÃâQ±­HNóA×`«$ÇÃ@U×%'O’µÈï¢ıŠzÛĞSàóÊ†œttO†Ê"Æé÷çxP“	w°Ø¢oŒ»æÁºú¬][š”êQ¸¯Şï”NDëv(ÌãÊ#/`8•‚E$ÖXİç!gDèÜJüÖDšH†Yd›I~}E´6¥Î‚N	ıç]1h›î»X‘d
6D«2ö?Ê!es^ô}‚Ù&âÓL;šåUexmÌÓçœq–øæUwVxÍ¦e@-8'ëşY®Ëîé•Tz+ZØ’Nzghë7”oUÊ^C³@»oëUËØm6L<¡2zµ
5¨Å¤ôèb±8gd™ËSxDFçô¤Òÿİq`¬"ÑãÕˆ-:îÀ¶â£Ã»RgÚÀ2Ò_è‰26Bı¬IxTcÖ\3ªÂ4‹:úW4²L<	ó°AS%o–;h¤ãÿB60DUÒø¾¡˜§)»ú{}EËsê©êŠCÔÈ¶î¯ÍjùÂ/ÚÔ8ÒDôBÙ uQK‹´/†\†tà¶pÈdM@!rÙ„as%Â`»–{v/ãMÕol ®„}\¤“(âÒ='/	J
iÃ¡{K½ÉæWléjš
M"k¹ˆSí	éõ]ş½Í&
e<G° uh2^–Á¾[%A¢B³àÜMô k«è"Ã5ÖŒ#‚˜)r:ËÆ
Ú¬ÒHNıHÅË\]QºÖ\®µi#BÚtl
ËNõKæeZÆæs°.…âîòö¬–iş‚zs
‘è¥
'¨RMşz9gSˆ·!Ô095ôû+j«h_>·S0«!„c²µö‚¾´:ı[<ÃÕVuËWâÄÙÔ´­Ğ×NSJ ŸÔÓ½¤vôìÏO%A‰2.BkGË{ËóKOr›âPÜ	ñM±ÄÑÇJê¹·8¾!§½¯é!‹üÛÎ—ÓÏGA“Xq§^0§“ìßkW“j‹F^ƒHÛ¿—¦]´¬Ò{$z„4´ÔÒ
ªÑ¦¸ëÀ’¸z×¥|tªo‚ó3—ôìÛá…úmš¢M¼Ê¤4î¨Ü¬€Îë£“b÷Ké$E?l€Ç½f¹Ÿ[ÄqP5šÍ5ì±¿jWÉia)KÈË5õ¹îúŞB¯I7V†¨Ué‰+!û—PŞz„ô­2eÄ¨fTHì“–|œÌœ±>—Q8ĞUL—áz¾b³lÒ¿Ü Z‹÷Qˆd¨±`åf\I¶Óóœ&ÑâµÛÆNUàÉä§ d/Øe&›BöÔÍzi¿vRâW¶“–[”é2Qàõ%2Ú5õƒt›6!tß;HåÀ‚VK;¼åq ••:çÀ›ÃN
úë[6ZÎşĞş”¦·®½KªBgè&î%W ºÏmMë¦Såî“<6'ÂëÔ2U 1M²;‚ æ'¾Û¨±ÉïtJ?yCO,â¡Ã³C±ÒĞñu—è8ÊÀËûçş.¡£âLO`WmP*ƒNHZÂÒ	¿"w5ØÏ¸ÛT_'HÂ!°Ë¤ïcG<	şÊÂîáñ[ÃAĞÇ/ƒQÛ`ƒÚ®òdĞw™&9X3Ì0;ªn/A	kY)§V/.á¹ïĞf(é>A¤ãñ[ò¨®ÏïÌÉY‹Áø©ú‘’{ù?ƒÇaü¹p„F*s„÷¡1„ÉR.?³¦!¼aêyŞêöºç‹\~¹—û!ËIh__³âÔ²ZÇz“ÿN‹¢ÿª–N™Ù	¥ ?,bãtH€Är€â^K½¦p†Vòmªdd#+œ ¾”şêÇfh7çîÖ‹¯t3 ñš‡"ì¿ÆÈR¡ø¡zĞ?P§²ŸwÉ­¶~[BJ¢c¨·²¥@×wá»yÊM/çİ¯É)2³ãÎfq¶²ŞÉè?]}¾•øœdö«@é1ì€¬kŸTWw;#‚¿ÂrHúÏäKÄ¾Ç%_ee“æ(-këºéªÀ¾6ÿ˜áó¸À˜(Î)Í«¤Ö­M‘Vëaì¯€–¸ëÃvøÛÇÙKÿ=EÉ zĞ5l£ÚÎÌüõ—v÷o¾ìqÙ=²uD3»»oÍ«ğKh©òÈJÓ°º/É§âÉ/GúÌÂú1Mş‰E^aek&;æ76ÓAú¯ÿ;
Í§P-Ÿé6Œ¯7şÚêjÎ‰ôÌ­-Cıïí¡Û ŒÌF`E	¦[Sã5*»ÑŞ¾Œ;ˆ†[lNJ#çöš™Îê±|mqÏÍ¦õabd½»ê3IP„àY#¨b^ ¥’!¹,Ê\‚ÓK ÁŞÅˆXø&Ôƒç
š­µTÀ5ş>l $2.¼ùl5k’dH{y¨"’'‰Dÿ?`„Å)pˆ/ÕdĞP°ÿdÔª¨] Ì–él’”_Üæ™9
âí-AkEà¾ü,GêÉÏ•xàUX H.gæı‹R×7m:¬T÷t³u¾*±$ˆı $Q@A›ÃcÖboÄ/ö~£hOØ©ÎÎdÃ.u¡è¢G b·´‡ñå5®Š‘>ÉßÂç/IKcsş3}?LÖMOcQ‚è²l¨Mœ>º²ÍÈ“){wò‡ñ	±U÷ôşÈ|RÂ÷1Hé$×%“¤+á:öóúöÏºxõÆ§üU1_ş^ bZ5­2†U_Ì)ì†¿í3îäñ:Ú|ÄUiX°ü¤>‹¤Û¿‡x´JN§ŞÌsJ2í"âøÓa¹0ØDßµ@Ÿ¦_	‹º›L¨ ³vU¯üÚÖË:ÕÇì{ë ¡œĞNOy“7¦ÀæÍvª©% X2O/”$cEŞR8 "ëÍ¹„¦“±d?ê³Ü)²Ûºé“‰ “;æ·H¼]s…\¤'aÑP?’½õÎä®™>Fçƒ"S²:ÊÒc#_R–¼yë’{<ùTHG¶‰dkRVJ¬«Z)²^8#8xJ&4ØÇş¤ãJ_Aº%eV
¡.kŠOˆ`Ñt%^ĞÁmÓ/q·»p’õh}gq¿ ~Ç¿ósÑ½ó‚ó"¥Ş\H6j„Låëu=p$BèåÔõ«…=?Öu_Š Dšj‚ãBí~L »–ol`ŠZmvf¼»˜ú[`‡9Z]±ŠÖ~ï*2ÿ™°kĞˆzÙ§®Nªzñ-nOS©A ™Ô#aov@c4®çÏ*:ß¨éwáR±&·ï4T‰}&ÿ“aİÂG3»dgf_;5Ùëªµ0Æ™ğ”´úğrMw¢ÏÊ¨±@ìæŞ7à¯ˆĞ*€zõWxP?Hë	ßÃy³å¼lİe+¿Øº:ck(’šNkø) ¦ZânòSåĞ&O"çù÷ÏJœxàÊĞ¹XLAyÉtBmKYŞÇühî·çfNÍŸÖRÉKº½’)QïÃªoœ«;ÕmX-êõ´%¼&¿ 	wãëÎ3dåE õÔ½x/lI­ Ò:LQ–¾bÅö¾\6-+}t¾ê·¹ÿm„ÊŞDzV(ĞÙ¸,‘Â6ÿ5Ø†4sLE‰B–æ²š;¯Â|]2*ÁPËLÁtê‰xÓØ£ò¡Cv’²”ØvÍ…Àÿ¥v€¢½C‘7‰KcYÎ{#tÏşMGk¼¶ë'ÄOg¾!@j°Ov¹î`0ıÉµÊ~
/e©9=7y„ˆªb%yw¸zV!èÇ˜ıîœ:ßó z!s·Î¦¡(İ¾,®vÉ»³F§¨@/¹ºPSjO‰9¦¥C*Î[\U¯üÙ›)£Ù“d,ûiT×E ë}Yo('ÖİWéù§’$]õ& ‰ˆ®Pg³€uBa2Šk8ôo*˜
(íêæ˜ùıŠ?R2ç5»ˆ²s²aÓ3*ÄLõÔ83’yéTö$dµ$Ê£€²x–A^ùr×!t˜_Vï…ê²V$Ò‘Ä¸ÇA	ÀÂ×ÓûdR°ë«§¶Ë±¾.¦lÅßo81üİŠà|Šê¼Zé§ŒCg¾:=–cPpR-Ô`BjC¯llX°sPaÂRbAí¶\¯Ï‡FX0ÊQ8Q½¦s±XƒÓL¦'H–Ê3VÛdfK,N®´Ô3
*ñÏÔÂ€ïPwaê“Ş,)EıT¡0ÑèO¶ÙlQRN\ı órœÜn†
ñbIaEºJe(í»mW; øe¥'x3OœFÃGN9QÒQÊ‘”Œd¬Ÿ}í®däLû?uü2ÎDR¥ò3?lı³-%xñº2¤Tdãfm/e83Tn.¤¸>šZo`èº¹×,c²©3t4Wæ]næ-ÃW%xí‰¿¬tr™2[»ä”¢KßzEš.ääV8ùÛáÕ ¸|±Å+ï´¤õ%¸º·†œaĞH;–Ì…%ÎÜÄ&§f×HâØb17õ·¶¢ü»°‰ê"Ó‚\å>Ëd©eıë™4Ñ=YepŒL#aKè¼>‚W“°0¾{ÚÆ0‡éäÛTDFàÈ¢”ƒzöL–{,@Ô‘ª®cå)şII.%:F
É#=2ÌÎ4ùƒÏù\¢}
IUL),Ä [Á-}uÙúä×q“V0}DHz‚£ ™¦hCìİ`ŠÊ”85’ärİÔxéªè¸Û=ò…¤}Ñv‘x({	EÓŸRï©†ò¨£\<‘Üf´~é×UOnßW‡zt«†@33\|´ë¦UéÕÏ‚Eò!‰! =¢yg8ØEUÇºMÀ	/¯'Š
EgÅÉ`ğ›°ÔQ°ãt#j¸¼ÎÇYÈƒ^ŠfËc%Ş'–š®UÂÀ¼•gÒlu Š-Kœì/ñj¦åGH›GŞÁNÔuGË>qÌß”6%‡äödß¤¢Ôµex§qé€ÜtNø´V®áñëm%mèÿ1[+EfeØ£úşş•—õÕmƒp2éy¼Éjn}|Kñ† ½õ²9¤*ÆBxJ¾K¤¶(½7™ÂËN&¥LâñÀ¬gàUÌ ›†."Ø:ÊÜÓRÌ…‚H†¤(
Ñ4á`ús(}¨Í~¨aûÍ—ÖËE¨EôRÆ€VF¯Ô¤½ójú¿˜¨ÔÁõö‰ÖÛT·W0X®’_=§X¸w¶=ÕµšŸn
8(`÷,aÁÎREZéŒâñ¨Ø'±›ë6xqÂs†‘WøTUAŸux*Nç{±s`™Ÿ‚è§`Ş¢şö¿ºaí×Â’Æç¾È†ğêò›¹ª¢ÉÒªZ»Vfäæ›1+'6rËKH€¹hR˜(ôš#óÿ† mEW¾9éwÕ@ºCêê<ègÖ©Ûm/ˆÛæ½´ß;¯C	qa0ûÎ½¹Êğ~\õv¦]¿“T0Øí³0ìcÜ…õ	^èê•_(Ì§Z1G‰§Ô ªŞ+Œë¹Õ¥Ë®ô”fe˜¶ÇğxvYŸ68¢Zúpø­û½Qè[ıQ?\ó*ºXÑ£az‰şes]‡u?ÌbäËp ]18aW¨øØ?Õ¼ËëR—æz‰Ü.İBTÈ4Å@ŞÔi}Öü¬v#“ª±Áç pÔŠ.f—s’'ƒ·—G&]å/Üy˜S=ğ.ÕULDNZü´°OŒ:lqĞa+Š}NÕE×Ö‰­Ñq#SÚ˜¯™T™•××|üvûa&FM³%¦Ù7…oõà¼ÜÅ·í«î!*¯{
å3Éß³c	[á@Ußux^FF*Q]€	¨°×„2r¤kbWQvöô&°ŠqUfOE¼«ğ8wlmé¡å;˜Ö4¿Ğn˜\9Rá+7§GŸ¿¡9³|¨=~lXp`‡ï¶?œ6â!RÒWVÏVÄÚçhË¦8µ2/ùbi–cÊÿJndêln"ğr§)£ë\&nX…ˆµ™ îóÙ»à‚/TsÔÀ?ÊSšOT ¡ñÁS¦êøB^>z š¨D ï2B­”[®OÄp¡V¾ö’LŠÁfh¸)KlsxguÂ´0É±LÁ°vÜ³e‚€˜Æ±İô7)İ6,zˆ)S·}À¸¿°˜'Npî¹âY×Ìîü]_Ü‹ö>÷Aˆ{´‡ØÅœàScÓi¹^{Îe¼³çM	¾ËöQ|ÓlŒíbj«nïœBO%Üiú–œ NìÎåÎ<Š¤P½üO|©BŠ‹C¯ÙÇYm;7á2Sº¨ê§J¿îTm¼¿ºRl¾–XÃ>…˜Å«,‚è7fŞOÚ¹Ÿ#cµÂ
yE³¨]NÃ!6ì2º­a¨ ¸°+ÏÚ¢š]LH9Úüõ£iH
^Şn]³C7©é¢í&S±P(=®¹?”½»Ğ»I«Ôæ”¢¾&Î€=¥Ú³œUc ‘›qNvË›	Q¡úõödÔ¸¢c¤H”dÈ
zÛ•Mx?‰YÜÕ¢(ø©œ1µÅ˜·åº
ºÀ–XUu°×YéÃÈ¥µiõ¼8bi-&Çœö3új*(çzMAZZ\
f`ÎxŸÌ×„ÄŒtŒjÙlgÓx>åó»ı2û­åZ!×3|(DÑƒ	´Å¦ÂWÊô.È10ÿsê©´ª1°"òúg.D8÷©®ƒoO|ÌÛr±¸ù–gp…Á
-¦ˆå8nl¶nİ¶»€ç`mvD‹MÁ2E?é&Òwu¨j¥r“Š6JoÀ˜"„¹ÈÆÆdÀûlz|…3?Çh×q×ò©İóL¯	<äÚ˜H²ÇÕYïeô®ÙTFxo³Ñ÷¨¡—ÓZájObSUlÙ_í·åœ()¹mCßNÆÔNŞM|Ö1ÎO¸ùLF½·EÛjœˆòÄrzääÌq$ÓŠ&ßÛ^6%e4ñMUãŸÆvâÑ#¾Åî¹Î|½‹c	3•dT!¡[·õe'Bá‘œNÎ*<÷÷cµ‘)g:T¶”ÌĞÒU}6F¾UOŠh‰¸GÁ”>§	}¶“Q…Ø³sşÖÑFP·L›;qPÖÍ†ŞXiCWé7ÜèÂ«Èr
ïÂâ@lÍCÚ@"ş¨®ê6ÄoISÜ¨VÅ>R/Ÿ^€\I×Wt)ÙÒ‹-œ¾:ÙãvÑ×ÑœR‘P?'nÔ-/\RZ…P…~ˆ&e$èH¬%›š4Í^"MšÆê¸H´›nš¢eÖyisúâhMÑÁËô\õæÄ45øºG¨ø~Óš`Ã!¡Ë§ÒÏŠÓbÄœrÒÓº$èzVZ~6€©]‚¢ò\}^›KIĞJŸ †ÿá,yŸX²§]¤îˆ}(¬V äÚÁ"Üê¼}…WĞ¼=Åä^Ÿ/=İTbb'@ét¾·Bú °şV=İò†0ˆ-5óg—,?ÙTÜpYlÏã?ş½Z\®îQCú†eÅÜı¸KLË>™Ã'].xé5¾“tôj-¼"kÊµ‚zõ±Ê>t¢‹áÈäP×ÿºÓ5|±*XOØ©Îâµl§ğà÷Ğ¦_FpN³]€dSh˜Ùùµ*F»iyÖ~™~©²`ÜÙSüŒ¶µùÉ<ÉÔÒßöOë.ó…t¿Uƒªx6zÍùÆÑÅ~q¡³˜KoaÇGj8·Qxÿ
i¡E€íµÿ°Û¾Ï*
€<Mãô{?qœM#-4¸)Ø}™‚~EKT¤ÜY¦üÇ‰éRibÂ¿mÁ%täJõwıUVæı%VĞó(Îçfqã2è6«/ùÉÌ¥D‰}=¦…Á¨/²# »¹o?Dû‹RbŸKÏ	}Í“ùğĞ›b(÷³O¤õp ™Š:Ó{Æj5”1–@)Ú˜¥üä”ËgSX#7„iT$«±=hŞÁ+ Å2(åãÌ[Œp¼õ.É\ŸwMÑzÿ@j®ÙB—ò|:7¿Y)µé„H7ƒú©:n©=?Ëp F]ÔÍ#ÓÁ;¨\¡˜
–¼şğcq¦5½\‡r>şEîËÄ6¸Óø]åú-'ÿñj_jÕçßà©¤åóK0;Ø7š€7Ö´3“IWÛÍ^@ÂhLã8!ÒƒÕHï³1ÈGPr:K³¡Ô”5óiCÈÑ1Ş#ëcStïÒÖË|jÖö›eŸÊ×uÀ¸¼ÑpCš=w0Ğıè
èaFƒÂÏ­Š'Æq<*İÍs8æ9Àk}yVT€k’S}2k—ú5½Ns¤xôWëäÔíôÆ;KÔóiÈ´L'WãìÃDÓw¹Ó©»/¶ÖB	9)mâ¥¥çşgé!µ©84@:m{rÌfûm”H‡3DÇ¿NÅ].‡Ş·iL„•0$8ÕéoÇAâ)´Èâ0®ÕÉx[–‡9kïŒšÖz–±öcëœ7šF³ÍGc|=\ü8hŒ›=«d_æññ¦4Ò»«×ÇŠL=H(í*®c»…Ií5´ôk:nDu¤ğÜ9¾ğ5JÒÇ¤6ÅÛ™aÇzÕøH;¡=œ,áaó/í¡á—Z·ô³«ù•µ–<å=ª/ÜµÉÓœpVxq9à±Ÿáå¼Ì7Ü8"_™ı¶›P|4š/Rp-'Òò¾¨Ài×W¤%ñĞA¼È‘c)ßG±n=%`W¶-îşÕU4ƒDíûNpÿRîÄ‰û
a
ì¬ä0b”ñŠTü‚@û¤¨ÿ´¤9£³ C½ÅçÒŠ²nX–Ã\Ù_ÂV=~–M_†qñ	0b·1{âëşqáŸ‰êGŞHŠæLÀ§+%ªDÚñ	'|e»ª <’eR¿èS_‡aŞêµvÓ‹°€!\µHH…`<ó<”Á$±ıºB¡îrÆrö/Úr–ˆyGU9‘Q½<%‹5±qâ‹¡¯zàå,/K*A'†Œ–è1¼÷ûnxÄg¥–b—zóùï–ñC·dçCj,"ÁdâV“ QTà¤’&5³·V<FìÅÛS@?ŸCåô‘Ûÿ<»_ÜIĞq­
q°½½iÄm›îæÔ†«õÓ¨f	±ËTîÈ“¬:Gƒ (óöæ˜Q¡÷624›=5?ÏÜI‘bšÖœQ-æ¾²@z½”3C·8"ÎJZ+í¦ñÕŸÁ
w,E­ùTË˜Nr{\TŠÎ‹I»¯NŸqaSYDå×B™R¦ôô0_FÀmÅmo4uÎ=1Ù6ş9¡8¡ {&WNŒÌ˜6¥_ßeÏÙ	Ó³qÈu‡Éı*T“Yyb²mreô@‹ôh´Ö6Ê,cîÓjºÄxæÄñÔK~W›4]*ôåG€×Ô®çö¢‰§YãQë,ØÀ=L·dm® {Cÿ	ˆ`şXÎºrSáÈ~U‚	”îÊ"É·3»|Gf¡q¡áiğ†u…Ï
­o™›Î²M›äš*h“loŠ…Ş©R„aâÂÑNR]*9^[Í]9ÜĞ g½MÂç$ÛòóôÑ§ù[ÜÎÆ	.“le]l5c]óIv¹ü±4K²²{+ƒ]¢Ü]¿ô»å* +Ûd>ÖrÏ™6nœ“™œ*öÙâúåÙ1\›-¦ÏÍİÃärªñäaÛ©P'h¸ÇËŠF’³¯XN9WbÚt™×¬ù{¢-–4Ä0‰të6ºßssm’Ö3¹›hçi¬©
èxMƒ¼‘ùĞ?n—ï.c.W…Ÿ}8«Ç3‰äó)Â¿9ˆìï²Õ)"¿GïªVÊ°Kº/Øş-XYÂ»ƒ¼p½fõDàÂ­Wœ
!O
u·×}w©3Û‰èÿØ_•±.=d´MSË×–ƒlh"î\ğ¦HrğDÍ3Íâ0ÅcƒgØ¶UtPw#*A™ÓÔƒÊÈDúyo%7=ı]·¢E!.çå C—><­’„ìõÏİÊ-Áœ”	C2&ÃWŒX¡TOyšûŒÚËa‰³(*”û ãÃÅ/ƒ×m*}˜LÔá\NÌÃPKèEaĞêÎTƒ`u,ÅUàÀNn/­n›jÿ¸¨¤’ªgpSó¼øÚ6N(cîšS5Üy9i¯ıÃÅPO¾ôŞÆDŠ &tE)]J3	…högn.’½·‹¡éläU‰Ñ„9Ş ™“Œëy_¢˜bfº»tà”zÉpìİÊ0ˆX•œbt"T ÁèğV«ßAk:OUhÏ?Î«ÔÔü#m2M¤Bîô)Z·Ÿy‰6¤QiTkZÇù ªªÁ[öi¬Ó6äÒ|Sih‡ÌO\nçZ“¦¨Í|İÂ~`£JšWëæµ`j„LÅİ¦ãs«&›ÂSŞít‚tXfÙÚ2‰â#ãYs¦OBoo¨3aÏáé›â1ÔÅªí~k3`Îué&¨è`óÒ¯œz)Íã™‚'®ïÚÔ†XNõÏ_¨bst¤bİ|ÿß™âyr
Ã¸<\=ü€çÁÖµ{Œ\¤œÍÃ­õÅs¸ö&÷•ß‡Uìà4 ³xëÙQÅ”?³	Xç¡œ[P«¬W…®	¶UDß=óMŞè§ğ«‚­~1¨ÿÿ<ôşò[}uÚ0³äÕÑÓãó<¨,:´ı+¶ÆŠ³4±ÿß{ØËéfñ,3fãmÜ÷©ˆ˜B}R^1¨‚ú+E¡<J*¢‚ğãŸğƒ^òMZ¤K>‹,?Ÿ1MSc]SJºñ”u¸#š²EEoJ#,­mÖ,flÂ¼¦Œ©Á·1RÎGNÙúª=Á£à´¹¡Ô†ıåë¦X¼Õ7ç";¤÷?¶{ÉoºÜÖNd¨ƒî·Ú^jÁæ¥“¤6ánÒ¨m»c;y¢q}bŒÿ	‡lÖLÖ‚s]ºN9¦8ŠG:zC`%ò‡Åx;è6“¸NîÜæÙLô÷O=×xµLÇéy»ğùëèO;©´Æ)zêá{‹L?êôê1ÀdnŸw7aZªéÔœ¨úèáíŒ9¡âöJİpB®äĞº5öØZh:#õ?Lf#6ÆÈeOUp«;—­§G~ßÉîúªrGK‚×‰Oaß¡LOé"jÖ’ÂŸD¥Iú”Êü€–Zœ%j¸ÛiÃpÜš†…­P%Væ‚£mšŠÁÔ—œ‰±í%ó.ÿI¾Û@’~E CÛ9~c‡“1ÖC>óÆ€ÔÖË)@•äbCçü’¨ÚqÅt¼ÔK§šâı&s‹Qç™¦4ÑO.vÀ!ÑD@¿ÕÒ@É¾‘ò@n3E1‚ò_ãØú«b7„/…”Œ²ÉÌÆêÏı‰ÊÇj>¬Ş:£$U£ğ´èwÓF´ŸBi“cŸÌSş‚ÿ°¸#…•<5-Årÿ	À;mØ½° ..Tõ,äF‘B
æ²15q™Ùx¡0˜Y]MòÍZ’É«˜’ãJ0$ÆÉÊ¸%cX_Â„vĞÜ–Ü›xÍŸ>cÔgÑDé’Ón¸«’™mÛØoø’^ö)QLØ3QŒ ­ÅbH´‘ÁéMfĞ?™Ò2‚YCC8•šNÇS0 º&XÄL§«¤ûÄøj¦’O®}fı¼‰0TcZ›Æã–m›1°øæd¯ÆEm„_J¤xì|s°/=Í’Ú¿cvÒOVÆzZŸ¨YÛ9=ûjÍ5ÅMwLx	Ûm–Çpj?#n.Dä³2NæàT#•Á‡ºÇ ßb:ÁêûtÇ&V¶^
+ïNùİÕÅ–ãõw–Ê«¬S‘¾ŠLD‚mA>*¯÷§ÒsÔí7ı4:DÆ>o¨ËØœ«B^³İË7ãk²z~Tyi P®ÑT¨t˜ÙnoÙ¦¥›3®ôá\˜ú6–:-'~w{:„W+ )âë’Vû‡?Š+MvBEbeU¿Ğ¥yÏÓtÁ